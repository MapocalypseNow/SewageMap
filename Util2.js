import{gJ as f,am as v,go as h,gt as m,gp as l,h$ as w,a_ as A,aG as $,gv as x}from"./index.js";import{s as E,c as b}from"./sphere.js";function p(r){return r?{origin:f(r.origin),vector:f(r.vector)}:{origin:v(),vector:v()}}function P(r,t,o=p()){return h(o.origin,r),m(o.vector,t,r),o}function S(r,t,o){return j(r,t,0,1,o)}function j(r,t,o,u,e){const{vector:i,origin:s}=r,n=m(b.get(),t,s),a=l(i,n)/w(i);return A(e,i,$(a,o,u)),x(e,e,r.origin)}new E(()=>p());class k{constructor(t){this.message=t}toString(){return`AssertException: ${this.message}`}}function _(r,t){if(!r){t=t||"Assertion";const o=new Error(t).stack;throw new k(`${t} at ${o}`)}}function d(r,t,o,u){let e,i=(o[0]-r[0])/t[0],s=(u[0]-r[0])/t[0];i>s&&(e=i,i=s,s=e);let n=(o[1]-r[1])/t[1],a=(u[1]-r[1])/t[1];if(n>a&&(e=n,n=a,a=e),i>a||n>s)return!1;n>i&&(i=n),a<s&&(s=a);let g=(o[2]-r[2])/t[2],c=(u[2]-r[2])/t[2];return g>c&&(e=g,g=c,c=e),!(i>c||g>s)&&(c<s&&(s=c),!(s<0))}export{P as b,d as i,S as j,_ as s,p as v};
