import{fB as U,b as S,f$ as G,g0 as ce,t as ae,cp as de,cq as Y,r as H,g1 as he,g2 as X,g3 as k,g4 as J,g5 as fe,g6 as ge,g7 as me,g8 as pe,g9 as ye,ga as xe,gb as Fe,gc as K,_ as Ie,gd as _e,fU as W,bf as Ve,ge as Te,gf as ve,eg as De}from"./index.js";import{f as be}from"./WhereClause.js";import{g as ee}from"./projectionSupport.js";import{E as $,v as O,b as te}from"./utils2.js";class Ae{constructor(t,e){this._cache=new U(t),this._invalidCache=new U(e)}get(t,e){const i=`${e.uid}:${t}`,a=this._cache.get(i);if(a)return a;if(this._invalidCache.get(i)!==void 0)return null;try{const s=be.create(t,e);return this._cache.put(i,s),s}catch{return this._invalidCache.put(i,null),null}}}const j=new Ae(50,500),w="feature-store:unsupported-query",ne=" as ",Se=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function Pe(u,t){if(!t)return!0;const e=j.get(t,u);if(!e)throw new S(w,"invalid SQL expression",{where:t});if(!e.isStandardized)throw new S(w,"where clause is not standard",{where:t});return Z(u,e.fieldNames,"where clause contains missing fields"),!0}function Ge(u,t,e){if(!t)return!0;const i=j.get(t,u);if(!i)throw new S(w,"invalid SQL expression",{having:t});if(!i.isAggregate)throw new S(w,"having does not contain a valid aggregate function",{having:t});const a=i.fieldNames;if(Z(u,a,"having contains missing fields"),!i.getExpressions().every(s=>{var l;const{aggregateType:r,field:n}=s,o=(l=u.get(n))==null?void 0:l.name;return e.some(h=>{var f;const{onStatisticField:c,statisticType:g}=h;return((f=u.get(c))==null?void 0:f.name)===o&&g.toLowerCase().trim()===r})}))throw new S(w,"expressions in having should also exist in outStatistics",{having:t});return!0}function N(u,t){return u?j.get(u,t):null}function Z(u,t,e,i=!0){const a=[];for(const s of t)if(s!=="*"&&!u.has(s))if(i){const r=re(s);try{const n=N(r,u);if(!n)throw new S(w,"invalid SQL expression",{where:r});if(!n.isStandardized)throw new S(w,"expression is not standard",{clause:n});Z(u,n.fieldNames,"expression contains missing fields")}catch(n){const o=n&&n.details;if(o&&(o.clause||o.where))throw n;o&&o.missingFields?a.push(...o.missingFields):a.push(s)}}else a.push(s);if(a.length)throw new S(w,e,{missingFields:a})}function re(u){return u.split(ne)[0]}function we(u){return u.split(ne)[1]}function $e(u,t){const e=t.get(u);return!!e&&!Se.has(e.type)}class q{constructor(t,e,i){var s;this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=(s=t.returnDistinctValues)!=null?s:!1,this.fieldsIndex=i,this.featureAdapter=e;const a=t.outFields;if(a&&!a.includes("*")){this.outFields=a;let r=0;for(const n of a){const o=re(n),l=this.fieldsIndex.get(o),h=l?null:N(o,i),c=l?l.name:we(n)||"FIELD_EXP_"+r++;this._fieldDataCache.set(n,{alias:c,clause:h})}}}countDistinctValues(t){return this.returnDistinctValues?(t.forEach(e=>this.getAttributes(e)),this._returnDistinctMap.size):t.length}getAttributes(t){const e=this._processAttributesForOutFields(t);return this._processAttributesForDistinctValues(e)}getFieldValue(t,e,i){var r;const a=i?i.name:e;let s=null;return this._fieldDataCache.has(a)?s=(r=this._fieldDataCache.get(a))==null?void 0:r.clause:i||(s=N(e,this.fieldsIndex),this._fieldDataCache.set(a,{alias:a,clause:s})),i?this.featureAdapter.getAttribute(t,a):s==null?void 0:s.calculateValue(t,this.featureAdapter)}getDataValue(t,e){const i=e.normalizationType,a=e.normalizationTotal;let s=e.field&&this.getFieldValue(t,e.field,this.fieldsIndex.get(e.field));if(e.field2&&(s=`${G(s)}${e.fieldDelimiter}${G(this.getFieldValue(t,e.field2,this.fieldsIndex.get(e.field2)))}`,e.field3&&(s=`${s}${e.fieldDelimiter}${G(this.getFieldValue(t,e.field3,this.fieldsIndex.get(e.field3)))}`)),i&&Number.isFinite(s)){const r=i==="field"&&e.normalizationField?this.getFieldValue(t,e.normalizationField,this.fieldsIndex.get(e.normalizationField)):null;s=ce(s,i,r,a)}return s}getExpressionValue(t,e,i,a){const s={attributes:this.featureAdapter.getAttributes(t),layer:{fields:this.fieldsIndex.fields}},r=a.createExecContext(s,i);return a.executeFunction(e,r)}getExpressionValues(t,e,i,a){const s={fields:this.fieldsIndex.fields};return t.map(r=>{const n={attributes:this.featureAdapter.getAttributes(r),layer:s},o=a.createExecContext(n,i);return a.executeFunction(e,o)})}validateItem(t,e){var i,a,s;return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:N(e,this.fieldsIndex)}),(s=(a=(i=this._fieldDataCache.get(e))==null?void 0:i.clause)==null?void 0:a.testFeature(t,this.featureAdapter))!=null?s:!1}validateItems(t,e){var i,a,s;return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:N(e,this.fieldsIndex)}),(s=(a=(i=this._fieldDataCache.get(e))==null?void 0:i.clause)==null?void 0:a.testSet(t,this.featureAdapter))!=null?s:!1}_processAttributesForOutFields(t){const e=this.outFields;if(!e||!e.length)return this.featureAdapter.getAttributes(t);const i={};for(const a of e){const{alias:s,clause:r}=this._fieldDataCache.get(a);i[s]=r?r.calculateValue(t,this.featureAdapter):this.featureAdapter.getAttribute(t,s)}return i}_processAttributesForDistinctValues(t){if(ae(t)||!this.returnDistinctValues)return t;const e=this.outFields,i=[];if(e)for(const r of e){const{alias:n}=this._fieldDataCache.get(r);i.push(t[n])}else for(const r in t)i.push(t[r]);const a=`${(e||["*"]).join(",")}=${i.join(",")}`;let s=this._returnDistinctMap.get(a)||0;return this._returnDistinctMap.set(a,++s),s>1?null:t}}function ze(u,t,e){return{objectId:u,target:t,distance:e,type:"vertex"}}function Ee(u,t,e,i,a,s=!1){return{objectId:u,target:t,distance:e,type:"edge",start:i,end:a,draped:s}}class Oe{constructor(t,e,i){this.items=t,this.query=e,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const t=new q(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:e,having:i,outStatistics:a}=this.query;if(!(e==null?void 0:e.length))return 1;const r=new Map,n=new Map,o=new Set;for(const l of a){const{statisticType:h}=l,c=h!=="exceedslimit"?l.onStatisticField:void 0;if(!n.has(c)){const d=[];for(const f of e){const y=this._getAttributeValues(t,f,r);d.push(y)}n.set(c,this._calculateUniqueValues(d,t.returnDistinctValues))}const g=n.get(c);for(const d in g){const{data:f,items:y}=g[d],V=f.join(",");i&&!t.validateItems(y,i)||o.add(V)}}return o.size}async createQueryResponse(){let t;if(this.query.outStatistics?t=this.query.outStatistics.some(e=>e.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):t=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry){const e=this.query.geometry;de(this.query.outSR)&&!Y(e.spatialReference,this.query.outSR)?t.queryGeometry=$({spatialReference:this.query.outSR,...ee(e,e.spatialReference,this.query.outSR)}):t.queryGeometry=$({spatialReference:this.query.outSR,...e})}return t}createSnappingResponse(t,e){const i=this.featureAdapter,a=ie(this.hasZ,this.hasM),{point:s,mode:r}=t,n=typeof t.distance=="number"?t.distance:t.distance.x,o=typeof t.distance=="number"?t.distance:t.distance.y,l={candidates:[]},h=this.geometryType==="esriGeometryPolygon",c=this._getPointCreator(r,this.spatialReference,e),g=new se(null,0),d=new se(null,0),f={x:0,y:0,z:0};for(const y of this.items){const V=i.getGeometry(y);if(ae(V))continue;const{coords:F,lengths:T}=V;if(g.coords=F,d.coords=F,t.types&P.EDGE){let I=0;for(let _=0;_<T.length;_++){const x=T[_];for(let m=0;m<x;m++,I+=a){const p=g;if(p.coordsIndex=I,m!==x-1){const v=d;v.coordsIndex=I+a;const C=f;Ce(f,s,p,v);const D=(s.x-C.x)/n,b=(s.y-C.y)/o,z=D*D+b*b;z<=1&&l.candidates.push(Ee(i.getObjectId(y),c(C),Math.sqrt(z),c(p),c(v)))}}}}if(t.types&P.VERTEX){const I=h?F.length-a:F.length;for(let _=0;_<I;_+=a){const x=g;x.coordsIndex=_;const m=(s.x-x.x)/n,p=(s.y-x.y)/o,v=m*m+p*p;v<=1&&l.candidates.push(ze(i.getObjectId(y),c(x),Math.sqrt(v)))}}}return l.candidates.sort((y,V)=>y.distance-V.distance),l}_getPointCreator(t,e,i){const a=H(i)&&!Y(e,i)?n=>ee(n,e,i):n=>n,{hasZ:s}=this,r=0;return t==="3d"?s?({x:n,y:o,z:l})=>a({x:n,y:o,z:l}):({x:n,y:o})=>a({x:n,y:o,z:r}):({x:n,y:o})=>a({x:n,y:o})}async createSummaryStatisticsResponse(t){const{field:e,valueExpression:i,normalizationField:a,normalizationType:s,normalizationTotal:r,minValue:n,maxValue:o,scale:l}=t,h=this.fieldsIndex.isDateField(e),c=await this._getDataValues({field:e,valueExpression:i,normalizationField:a,normalizationType:s,normalizationTotal:r,scale:l}),g=he({normalizationType:s,normalizationField:a,minValue:n,maxValue:o}),d=this.fieldsIndex.get(e),f={value:.5,fieldType:d==null?void 0:d.type},y=X(d)?k({values:c,supportsNullCount:g,percentileParams:f}):J({values:c,minValue:n,maxValue:o,useSampleStdDev:!s,supportsNullCount:g,percentileParams:f});return fe(y,h)}async createUniqueValuesResponse(t){const{field:e,valueExpression:i,domains:a,returnAllCodedValues:s,scale:r}=t,n=await this._getDataValues({field:e,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,valueExpression:i,scale:r}),o=ge(n);return me(o,a,s,t.fieldDelimiter)}async createClassBreaksResponse(t){const{field:e,valueExpression:i,normalizationField:a,normalizationType:s,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:h,numClasses:c,scale:g}=t,d=await this._getDataValues({field:e,valueExpression:i,normalizationField:a,normalizationType:s,normalizationTotal:r,scale:g}),f=pe(d,{field:e,normalizationField:a,normalizationType:s,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:h,numClasses:c});return ye(f,n)}async createHistogramResponse(t){const{field:e,valueExpression:i,normalizationField:a,normalizationType:s,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:h,numBins:c,scale:g}=t,d=await this._getDataValues({field:e,valueExpression:i,normalizationField:a,normalizationType:s,normalizationTotal:r,scale:g});return xe(d,{field:e,normalizationField:a,normalizationType:s,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:h,numBins:c})}_sortFeatures(t,e,i){if(t.length>1&&e&&e.length)for(const a of e.reverse()){const s=a.split(" "),r=s[0],n=this.fieldsIndex.get(r),o=!!s[1]&&s[1].toLowerCase()==="desc",l=Fe(n==null?void 0:n.type,o);t.sort((h,c)=>{const g=i(h,r,n),d=i(c,r,n);return l(g,d)})}}_createFeatureQueryResponse(t){const e=this.items,{geometryType:i,hasM:a,hasZ:s,objectIdField:r,spatialReference:n}=this,{outFields:o,outSR:l,quantizationParameters:h,resultRecordCount:c,resultOffset:g,returnZ:d,returnM:f}=t,y=c!=null&&e.length>(g||0)+c,V=o&&(o.includes("*")?[...this.fieldsIndex.fields]:o.map(F=>this.fieldsIndex.get(F)));return{exceededTransferLimit:y,features:this._createFeatures(t,e),fields:V,geometryType:i,hasM:a&&f,hasZ:s&&d,objectIdFieldName:r,spatialReference:$(l||n),transform:h&&K(h)||null}}_createFeatures(t,e){var x;const i=new q(t,this.featureAdapter,this.fieldsIndex),{hasM:a,hasZ:s}=this,{orderByFields:r,quantizationParameters:n,returnGeometry:o,returnCentroid:l,maxAllowableOffset:h,resultOffset:c,resultRecordCount:g,returnZ:d=!1,returnM:f=!1}=t,y=s&&d,V=a&&f;let F=[],T=0;const I=[...e];if(this._sortFeatures(I,r,(m,p,v)=>i.getFieldValue(m,p,v)),o||l){const m=(x=K(n))!=null?x:void 0;if(o&&!l)for(const p of I)F[T++]={attributes:i.getAttributes(p),geometry:O(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(p),h,m,y,V)};else if(!o&&l)for(const p of I)F[T++]={attributes:i.getAttributes(p),centroid:te(this,this.featureAdapter.getCentroid(p,this),m)};else for(const p of I)F[T++]={attributes:i.getAttributes(p),centroid:te(this,this.featureAdapter.getCentroid(p,this),m),geometry:O(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(p),h,m,y,V)}}else for(const m of I){const p=i.getAttributes(m);p&&(F[T++]={attributes:p})}const _=c||0;if(g!=null){const m=_+g;F=F.slice(_,Math.min(F.length,m))}return F}_createExceedsLimitQueryResponse(t){var r;let e=!1,i=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY;for(const n of(r=t.outStatistics)!=null?r:[])if(n.statisticType==="exceedslimit"){i=n.maxPointCount!=null?n.maxPointCount:Number.POSITIVE_INFINITY,a=n.maxRecordCount!=null?n.maxRecordCount:Number.POSITIVE_INFINITY,s=n.maxVertexCount!=null?n.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")e=this.items.length>i;else if(this.items.length>a)e=!0;else{const n=ie(this.hasZ,this.hasM),o=this.featureAdapter;e=this.items.reduce((l,h)=>{const c=o.getGeometry(h);return l+(H(c)&&c.coords.length||0)},0)/n>s}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(t){const e={attributes:{}},i=[],a=new Map,s=new Map,r=new Map,n=new Map,o=new q(t,this.featureAdapter,this.fieldsIndex),l=t.outStatistics,{groupByFieldsForStatistics:h,having:c,orderByFields:g}=t,d=h&&h.length,f=!!d,y=f?h[0]:null,V=f&&!this.fieldsIndex.get(y);for(const T of l!=null?l:[]){const{outStatisticFieldName:I,statisticType:_}=T,x=T,m=_!=="exceedslimit"?T.onStatisticField:void 0,p=_==="percentile_disc"||_==="percentile_cont",v=_==="EnvelopeAggregate"||_==="CentroidAggregate"||_==="ConvexHullAggregate",C=f&&d===1&&(m===y||V)&&_==="count";if(f){if(!r.has(m)){const b=[];for(const z of h){const M=this._getAttributeValues(o,z,a);b.push(M)}r.set(m,this._calculateUniqueValues(b,!v&&o.returnDistinctValues))}const D=r.get(m);for(const b in D){const{count:z,data:M,items:Q,itemPositions:oe}=D[b],L=M.join(",");if(!c||o.validateItems(Q,c)){const E=n.get(L)||{attributes:{}};if(v){E.aggregateGeometries||(E.aggregateGeometries={});const{aggregateGeometries:A,outStatisticFieldName:R}=await this._getAggregateGeometry(x,Q);E.aggregateGeometries[R]=A}else{let A=null;if(C)A=z;else{const R=this._getAttributeValues(o,m,a),B=oe.map(ue=>R[ue]);A=p&&"statisticParameters"in x?this._getPercentileValue(x,B):this._getStatisticValue(x,B,null,o.returnDistinctValues)}E.attributes[I]=A}let le=0;h.forEach((A,R)=>E.attributes[this.fieldsIndex.get(A)?A:"EXPR_"+ ++le]=M[R]),n.set(L,E)}}}else if(v){e.aggregateGeometries||(e.aggregateGeometries={});const{aggregateGeometries:D,outStatisticFieldName:b}=await this._getAggregateGeometry(x,this.items);e.aggregateGeometries[b]=D}else{const D=this._getAttributeValues(o,m,a);e.attributes[I]=p&&"statisticParameters"in x?this._getPercentileValue(x,D):this._getStatisticValue(x,D,s,o.returnDistinctValues)}i.push({name:I,alias:I,type:"esriFieldTypeDouble"})}const F=f?Array.from(n.values()):[e];return this._sortFeatures(F,g,(T,I)=>T.attributes[I]),{fields:i,features:F}}async _getAggregateGeometry(t,e){const i=await Ie(()=>import("./geometryEngineJSON2.js"),["geometryEngineJSON2.js","geometryEngineBase.js","geometryEngineJSON.js","json.js"]),{statisticType:a,outStatisticFieldName:s}=t,{featureAdapter:r,spatialReference:n,geometryType:o,hasZ:l,hasM:h}=this,c=e.map(f=>O(o,l,h,r.getGeometry(f))),g=i.convexHull(n,c,!0)[0],d={aggregateGeometries:null,outStatisticFieldName:null};if(a==="EnvelopeAggregate"){const f=g?_e(g):W(i.union(n,c));d.aggregateGeometries={...f,spatialReference:n},d.outStatisticFieldName=s||"extent"}else if(a==="CentroidAggregate"){const f=g?Ve(g):Te(W(i.union(n,c)));d.aggregateGeometries={x:f[0],y:f[1],spatialReference:n},d.outStatisticFieldName=s||"centroid"}else a==="ConvexHullAggregate"&&(d.aggregateGeometries=g,d.outStatisticFieldName=s||"convexHull");return d}_getStatisticValue(t,e,i,a){const{onStatisticField:s,statisticType:r}=t;let n=null;return n=i!=null&&i.has(s)?i.get(s):X(this.fieldsIndex.get(s))?k({values:e,returnDistinct:a}):J({values:e,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(s,n),n[r==="var"?"variance":r]}_getPercentileValue(t,e){const{onStatisticField:i,statisticParameters:a,statisticType:s}=t,{value:r,orderBy:n}=a,o=this.fieldsIndex.get(i);return ve(e,{value:r,orderBy:n,fieldType:o==null?void 0:o.type,isDiscrete:s==="percentile_disc"})}_getAttributeValues(t,e,i){if(i.has(e))return i.get(e);const a=this.fieldsIndex.get(e),s=this.items.map(r=>t.getFieldValue(r,e,a));return i.set(e,s),s}_getAttributeDataValues(t,e){return this.items.map(i=>t.getDataValue(i,{field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal}))}async _getAttributeExpressionValues(t,e,i){const{arcadeUtils:a}=await De(),s=a.createFunction(e),r=i&&a.getViewInfo(i);return t.getExpressionValues(this.items,s,r,a)}_calculateUniqueValues(t,e){const i={},a=this.items,s=a.length;for(let r=0;r<s;r++){const n=a[r],o=[];for(const h of t)o.push(h[r]);const l=o.join(",");e?i[l]==null&&(i[l]={count:1,data:o,items:[n],itemPositions:[r]}):i[l]==null?i[l]={count:1,data:o,items:[n],itemPositions:[r]}:(i[l].count++,i[l].items.push(n),i[l].itemPositions.push(r))}return i}async _getDataValues(t){const e=new q(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:i,field:a,normalizationField:s,normalizationType:r,normalizationTotal:n,scale:o}=t,l=i?{viewingMode:"map",scale:o,spatialReference:this.query.outSR||this.spatialReference}:null;return i?this._getAttributeExpressionValues(e,i,l):this._getAttributeDataValues(e,{field:a,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,normalizationField:s,normalizationType:r,normalizationTotal:n})}}function Ce(u,t,e,i){const a=i.x-e.x,s=i.y-e.y,r=a*a+s*s,n=(t.x-e.x)*a+(t.y-e.y)*s,o=Math.min(1,Math.max(0,n/r));u.x=e.x+a*o,u.y=e.y+s*o}function ie(u,t){return u?t?4:3:t?3:2}var P;(function(u){u[u.NONE=0]="NONE",u[u.EDGE=1]="EDGE",u[u.VERTEX=2]="VERTEX"})(P||(P={}));class se{constructor(t,e){this.coords=t,this.coordsIndex=e}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}export{Oe as A,P as D,Ge as a,Z as c,$e as f,N as l,Pe as o};
