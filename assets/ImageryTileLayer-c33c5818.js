import{e9 as nt,dz as fe,K as k,ka as qe,F as Ue,s as $,f1 as at,aK as N,X as U,P as M,dV as W,U as Ve,bE as ot,a6 as lt,aB as w,aC as b,dy as Xe,aD as K,dl as ct,y as J,a_ as ut,eb as Ye,E as Ke,T as ht,a7 as ft,dN as dt,B as mt,je as pt,jf as yt,dr as gt,ds as xt,jY as It,jX as wt,jg as bt,dt as St,bm as vt,dU as he,jk as Tt,as as Rt,jh as _t,fk as kt,jP as Ct,k as Pt,dw as Ft,r as Mt}from"./vendor-f61b19da.js";import{c as $t,w as Ot,l as Qe,$ as Be,V as Bt,L as Dt,j as Et,n as zt,m as Nt,u as Jt,o as Ht,a as Lt}from"./fetchRasterInfo-cc1bf3f6.js";import{f as Ze,g as At,i as Wt,s as jt,p as et,c as De,m as Gt,d as qt}from"./multidimensionalUtils-1d836269.js";import{S as Ut,b as de,T as Vt,r as Ee,e as me,p as Xt,j as Pe,P as Yt,l as Kt,N as Qt,D as Zt,m as ye,G as ei,q as ti,O as ii}from"./RasterSymbolizer-db9d2121.js";import{a as ze,x as Ne,h as Je,d as si,m as ri}from"./RawBlockCache-5039b8be.js";import{T as ve,D as ni,j as ai,W as oi,b as li,g as ci}from"./pixelUtils-e7c1af11.js";import{T as He,U as ge,j as Le,o as Ae,n as ui,Q as Te,J as Re,$ as hi,V as fi,C as di}from"./rasterProjectionHelper-d922921e.js";import{m as mi,b as pi,d as yi,f as gi}from"./dataUtils-b154db54.js";import{l as tt,f as xi,i as Ii,m as Fe,c as wi}from"./utils-571d434d.js";import{n as bi,z as Si}from"./TilemapCache-2ed8b724.js";const xe=8;let q=class extends nt(ct){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const t=He();this.addResolvingPromise(t),await this.when()}normalizeCtorArgs(t){return t&&t.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:fe.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,e=ge(t.spatialReference);return k(e)&&t.extent.width>=e/2}set url(t){this._set("url",qe(t,Ue.getLogger(this.declaredClass)))}async open(t){throw new $("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(t,e,r,i={}){const s=i.tileInfo||this.rasterInfo.storageInfo.tileInfo,n=this.getTileExtentFromTileInfo(t,e,r,s);return this.fetchPixels(n,s.size[0],s.size[1],i)}async identify(t,e={}){var _;t=at(N,t).clone().normalize();const{multidimensionalDefinition:r,timeExtent:i}=e,{hasMultidimensionalTranspose:s,multidimensionalInfo:n}=this.rasterInfo;let{transposedVariableName:a}=e;const l=k(n)&&s&&(i!=null||Ze(r));l&&!a&&(a=k(r)&&r.length>0?r[0].variableName??void 0:n.variables[0].name,e={...e,transposedVariableName:a}),e=this._getRequestOptionsWithSliceId(e);const{spatialReference:o,extent:c}=this.rasterInfo,{datumTransformation:u}=e;let f=Le(t,o,u);if(!c.intersects(f))return{location:f,value:null};if(k(this.rasterInfo.transform)){const F=this.rasterInfo.transform.inverseTransform(f);if(!this.rasterInfo.nativeExtent.intersects(F))return{location:F,value:null};f=F}let d=0;const h=k(a)&&k(n)&&this.rasterInfo.hasMultidimensionalTranspose;if(!h){if(e.srcResolution)d=Ae(e.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel;else if(d=await this.computeBestPyramidLevelForLocation(t,e),d==null)return{location:f,value:null}}const y=this.identifyPixelLocation(f,d,null,h);if(y===null)return{location:f,value:null};const{row:p,col:m,rowOffset:g,colOffset:x,blockWidth:I}=y,C=a??U(e.sliceId),P=ze(this.url,C),T=`${d}/${p}/${m}`;let v=Ne(P,null,T);M(v)&&(v=this.fetchRawTile(d,p,m,e),Je(P,null,T,v));const R=await v;if(M(R)||!((_=R.pixels)!=null&&_.length))return{location:f,value:null};const S=g*I+x;return this._processIdentifyResult(R,{srcLocation:f,position:S,pyramidLevel:d,useTransposedTile:!!h,requestSomeSlices:l,identifyOptions:e})}async fetchPixels(t,e,r,i={}){if(t=ui(t),(i=this._getRequestOptionsWithSliceId(i)).requestRawData)return this._fetchPixels(t,e,r,i);const s=ge(t.spatialReference),n=Te(t);if(M(s)||n===0||n===1&&this._isGlobalWrappableSource)return this._fetchPixels(t,e,r,i);if(n>=3)return{extent:t,pixelBlock:null};const a=[],{xmin:l,xmax:o}=t,c=Math.round(s/(o-l)*e),u=c-Math.round((s/2-l)/(o-l)*e);let f=0;const d=[];for(let m=0;m<=n;m++){const g=new W({xmin:m===0?l:-s/2,xmax:m===n?o-s*m:s/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),x=m===0?c-u:m===n?e-f:c;f+=x,d.push(x);const I=i.disableWrapAround&&m>0?null:this._fetchPixels(g,x,r,i);a.push(I)}const h=(await Promise.all(a)).map(m=>m==null?void 0:m.pixelBlock);let y=null;const p={width:e,height:r};return this.rasterJobHandler?y=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:p,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:d},i)).pixelBlock:y=ve(h,p,{blockWidths:d}),{extent:t,srcExtent:Re(t,this.rasterInfo.spatialReference,i.datumTransformation),pixelBlock:y}}async fetchRawPixels(t,e,r,i={}){e={x:Math.floor(e.x),y:Math.floor(e.y)};const s=await this._fetchRawTiles(t,e,r,i),{nativeExtent:n,nativePixelSize:a,storageInfo:l}=this.rasterInfo,o=2**t,c=a.x*o,u=a.y*o,f=new W({xmin:n.xmin+c*e.x,xmax:n.xmin+c*(e.x+r.width-1),ymin:n.ymax-u*(e.y+r.height-1),ymax:n.ymax-u*e.y,spatialReference:n.spatialReference});if(!s)return{extent:f,srcExtent:f,pixelBlock:null};const{pixelBlocks:d,mosaicSize:h}=s;if(d.length===1&&k(d[0])&&d[0].width===r.width&&d[0].height===r.height)return{extent:f,srcExtent:f,pixelBlock:s.pixelBlocks[0]};const y=t>0?l.pyramidBlockWidth:l.blockWidth,p=t>0?l.pyramidBlockHeight:l.blockHeight,m={x:e.x%y,y:e.y%p};let g;return this.rasterJobHandler?g=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:h,destDimension:r,clipOffset:m,clipSize:r,coefs:null,sampleSpacing:null,interpolation:i.interpolation,alignmentInfo:null,blockWidths:null},i)).pixelBlock:g=ve(d,h,{clipOffset:m,clipSize:r}),{extent:f,srcExtent:f,pixelBlock:g}}fetchRawTile(t,e,r,i){throw new $("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return Re(this.rasterInfo.extent,t)}decodePixelBlock(t,e){return!this.rasterJobHandler||e.useCanvas?Ut(t,e):this.rasterJobHandler.decode({data:t,options:e})}async request(t,e,r=0){const{customFetchParameters:i}=this.ioConfig,{range:s,query:n,headers:a}=e;r=r??e.retryCount??this.ioConfig.retryCount;const l=s?{Range:`bytes=${s.from}-${s.to}`}:null;try{return await Ve(t,{...e,query:{...n,...i},headers:{...a,...l}})}catch(o){if(r>0)return r--,this.request(t,e,r);throw o}}getSliceIndex(t){const{multidimensionalInfo:e}=this.rasterInfo;return M(e)||M(t)||t.length===0?null:At(t,e)}getTileExtentFromTileInfo(t,e,r,i){const s=ot(i.lodAt(t));return this.getTileExtent({x:s.resolution,y:s.resolution},e,r,i.origin,i.spatialReference,i.size)}updateTileInfo(){const{storageInfo:t,spatialReference:e,extent:r,pixelSize:i}=this.rasterInfo;if(!t.tileInfo){const s=[],n=t.maximumPyramidLevel||0;let a=Math.max(i.x,i.y),l=1/.0254*96*a;for(let c=0;c<=n;c++)s.push({level:n-c,resolution:a,scale:l}),a*=2,l*=2;const o=new N({x:r.xmin,y:r.ymax,spatialReference:e});t.tileInfo=new fe({origin:o,size:[t.blockWidth,t.blockHeight],spatialReference:e,lods:s}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,e=512,r=512,i){const{width:s,height:n,nativeExtent:a,pixelSize:l,spatialReference:o}=t,c=new N({x:a.xmin,y:a.ymax,spatialReference:o});i==null&&(i=Math.max(0,Math.round(Math.log(Math.max(s,n))/Math.LN2-8)));const u=this.computeBlockBoundary(a,512,512,{x:a.xmin,y:a.ymax},[l],i);t.storageInfo=new de({blockWidth:e,blockHeight:r,pyramidBlockWidth:e,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:i,blockBoundary:u})}async computeBestPyramidLevelForLocation(t,e={}){return 0}computeBlockBoundary(t,e,r,i,s,n=0,a=2){if(s.length===1&&n>0){s=[...s];let{x:u,y:f}=s[0];for(let d=0;d<n;d++)u*=a,f*=a,s.push({x:u,y:f})}const l=[],{x:o,y:c}=i;for(let u=0;u<s.length;u++){const{x:f,y:d}=s[u];l.push({minCol:Math.floor((t.xmin-o+.1*f)/e/f),maxCol:Math.floor((t.xmax-o-.1*f)/e/f),minRow:Math.floor((c-t.ymax+.1*d)/r/d),maxRow:Math.floor((c-t.ymin-.1*d)/r/d)})}return l}getPyramidPixelSize(t){const{nativePixelSize:e}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:i}=this.rasterInfo.storageInfo;if(t===0)return e;if(k(r)&&r.length)return r[t-1];const s=i**t;return{x:e.x*s,y:e.y*s}}identifyPixelLocation(t,e,r,i){const{spatialReference:s,nativeExtent:n,storageInfo:a}=this.rasterInfo,{maximumPyramidLevel:l,origin:o,transposeInfo:c}=a,u=i&&k(c)?c.tileSize[0]:a.blockWidth,f=i&&k(c)?c.tileSize[1]:a.blockHeight,d=Le(t,s,r);if(!n.intersects(d)||e<0||e>l)return null;const h=this.getPyramidPixelSize(e),{x:y,y:p}=h,m=(o.y-d.y)/p/f,g=(d.x-o.x)/y/u,x=Math.min(f-1,Math.floor((m-Math.floor(m))*f)),I=Math.min(u-1,Math.floor((g-Math.floor(g))*u));return{pyramidLevel:e,row:Math.floor(m),col:Math.floor(g),rowOffset:x,colOffset:I,blockWidth:u,srcLocation:d}}getTileExtent(t,e,r,i,s,n){const[a,l]=n,o=i.x+r*a*t.x,c=o+a*t.x,u=i.y-e*l*t.y,f=u-l*t.y;return new W({xmin:o,xmax:c,ymin:f,ymax:u,spatialReference:s})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,e,r){const i=this.rasterInfo.storageInfo.blockBoundary[t];return!i||i.maxRow<e||i.maxCol<r||i.minRow>e||i.minCol>r}async _fetchPixels(t,e,r,i={}){let s=Te(t);if(s>=2)return{extent:t,pixelBlock:null};const n=this._getSourceDataInfo(t,e,r,i),{pyramidLevel:a,pyramidResolution:l,srcResolution:o,srcExtent:c,srcWidth:u,srcHeight:f}=n;if(u===0||f===0)return{extent:t,srcExtent:c,pixelBlock:null};const d=U(this.rasterInfo.transform),h=(d==null?void 0:d.type)==="gcs-shift",y=k(ge(t.spatialReference));!h&&y||(s=Te(n.srcExtent,h));const p=this.rasterInfo.storageInfo,m={x:Math.floor((c.xmin-p.origin.x)/l.x+.1),y:Math.floor((p.origin.y-c.ymax)/l.y+.1)},g=await this._fetchRawTiles(a,m,{width:u,height:f,wrapCount:s},i);if(!g)return{extent:t,srcExtent:c,pixelBlock:null};const x=a>0?p.pyramidBlockWidth:p.blockWidth,I=a>0?p.pyramidBlockHeight:p.blockHeight,C=x===u&&I===f&&m.x%x==0&&m.y%I==0,P=new N({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/r,spatialReference:t.spatialReference}),T=!t.spatialReference.equals(this.rasterInfo.spatialReference),{datumTransformation:v}=i;if(!T&&C&&g.pixelBlocks.length===1&&x===e&&I===r&&o.x===P.x&&o.y===P.y)return{extent:t,srcExtent:c,pixelBlock:g.pixelBlocks[0]};const R=y&&k(ge(c.spatialReference)),S=i.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");S&&!this.rasterJobHandler&&await He();const _=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:g.extent,pixelSize:P.toJSON(),datumTransformation:v,rasterTransform:d,hasWrapAround:s>0||R,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:S},i):hi({projectedExtent:t,srcBufferExtent:g.extent,pixelSize:P,datumTransformation:v,rasterTransform:d,hasWrapAround:s>0||R,isAdaptive:!1,includeGCSGrid:S});let F;const E=!i.requestRawData,j={rows:_.spacing[0],cols:_.spacing[1]},H=U(this._getRasterTileAlignmentInfo(a,g.extent.xmin)),{pixelBlocks:B,mosaicSize:L,isPartiallyFilled:G}=g;let V=null;if(this.rasterJobHandler)({pixelBlock:F,localNorthDirections:V}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:B,srcMosaicSize:L,destDimension:E?{width:e,height:r}:null,coefs:E?_.coefficients:null,sampleSpacing:E?j:null,projectDirections:S,gcsGrid:S?_.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:i.interpolation,alignmentInfo:H,blockWidths:null},i));else{const D=ve(B,L,{alignmentInfo:H});F=E?ni(D,{width:e,height:r},_.coefficients,j,i.interpolation):D,S&&_.gcsGrid&&(V=ai({width:e,height:r},_.gcsGrid),F=mi(F,this.rasterInfo.dataType,V))}return i.requestRawData||S?{srcExtent:c,pixelBlock:F,transformGrid:_,localNorthDirections:V,extent:t,isPartiallyFilled:G}:{srcExtent:c,extent:t,pixelBlock:F}}async _fetchRawTiles(t,e,r,i){const{origin:s,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:l}=this.getBlockWidthHeight(t);let{x:o,y:c}=e,{width:u,height:f,wrapCount:d}=r;const h=this._getRasterTileAlignmentInfo(t,0);i.buffer&&(o-=i.buffer.cols,c-=i.buffer.rows,u+=2*i.buffer.cols,f+=2*i.buffer.rows);let y=0,p=0,m=0;d&&k(h)&&({worldColumnCountFromOrigin:p,originColumnOffset:m,rightPadding:y}=h,p*h.blockWidth-y>=o+u&&(y=0));const g=Math.floor(o/a),x=Math.floor(c/l),I=Math.floor((o+u+y-1)/a),C=Math.floor((c+f+y-1)/l),P=n[t];if(!P)return null;const{minRow:T,minCol:v,maxCol:R,maxRow:S}=P;if(d===0&&(C<T||I<v||x>S||g>R))return null;const _=new Array;let F=!1;const E=this.ioConfig.allowPartialFill==null?i.allowPartialFill:this.ioConfig.allowPartialFill;for(let D=x;D<=C;D++)for(let ae=g;ae<=I;ae++){let pe=ae;if(!i.disableWrapAround&&d&&k(h)&&p<=ae&&(pe=ae-p-m),D>=T&&pe>=v&&S>=D&&R>=pe){const $e=this._fetchRawTile(t,D,pe,i);E?_.push(new Promise(Oe=>{$e.then(rt=>Oe(rt)).catch(()=>{F=!0,Oe(null)})})):_.push($e)}else _.push(Promise.resolve(null))}if(_.length===0)return null;const j=await Promise.all(_),H={height:(C-x+1)*l,width:(I-g+1)*a},{spatialReference:B}=this.rasterInfo,L=this.getPyramidPixelSize(t),{x:G,y:V}=L;return{extent:new W({xmin:s.x+g*a*G,xmax:s.x+(I+1)*a*G,ymin:s.y-(C+1)*l*V,ymax:s.y-x*l*V,spatialReference:B}),pixelBlocks:j,mosaicSize:H,isPartiallyFilled:F}}_fetchRawTile(t,e,r,i){const s=this.rasterInfo.storageInfo.blockBoundary[t];if(!s)return Promise.resolve(null);const{minRow:n,minCol:a,maxCol:l,maxRow:o}=s;if(e<n||r<a||e>o||r>l)return Promise.resolve(null);const c=ze(this.url,i.sliceId),u=`${t}/${e}/${r}`;let f=Ne(c,i.registryId,u);if(M(f)){const d=new AbortController;f=this.fetchRawTile(t,e,r,{...i,signal:d.signal}),Je(c,i.registryId,u,f,d),f.catch(()=>si(c,i.registryId,u))}return i.signal&&lt(i,()=>{ri(c,i.registryId,u)}),f}_computeMagDirValues(t){var o;const{bandCount:e,dataType:r}=this.rasterInfo;if(!(e===2&&r==="vector-magdir"||r==="vector-uv")||(t==null?void 0:t.length)!==2||!((o=t[0])!=null&&o.length))return null;const i=t[0].length;if(r==="vector-magdir"){const c=t[1].map(u=>(u+360)%360);return[t[0],c]}const[s,n]=t,a=[],l=[];for(let c=0;c<i;c++){const[u,f]=pi([s[c],n[c]]);a.push(u),l.push(f)}return[a,l]}_getRasterTileAlignmentInfo(t,e){return this._rasterTileAlighmentInfo==null&&(this._rasterTileAlighmentInfo=fi(this.rasterInfo)),M(this._rasterTileAlighmentInfo.pyramidsInfo)?null:{startX:e,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,e,r,i={}){const s={datumTransformation:i.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0};i.srcResolution&&(s.srcResolution=i.srcResolution,this._updateSourceDataInfo(t,s));const n=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:a,srcHeight:l,pyramidLevel:o}=s,c=a/e,u=l/r,f=o<n&&c*u>=16;if(f||o===n&&(c>xe||u>xe)||a===0||l===0){const d=new N({x:(t.xmax-t.xmin)/e,y:(t.ymax-t.ymin)/r,spatialReference:t.spatialReference});let h=di(d,this.rasterInfo.spatialReference,t,s.datumTransformation);const y=!h||i.srcResolution&&h.x+h.y<i.srcResolution.x+i.srcResolution.y;if(f&&i.srcResolution&&y){const p=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(n-o+3>=p){const m=2**p;h={x:i.srcResolution.x*m,y:i.srcResolution.y*m}}}h&&(s.srcResolution=h,this._updateSourceDataInfo(t,s))}return(s.srcWidth/e>xe||s.srcHeight/r>xe)&&(s.srcWidth=0,s.srcHeight=0),s}_updateSourceDataInfo(t,e){e.srcWidth=0,e.srcHeight=0;const r=this.rasterInfo.spatialReference,{srcResolution:i,datumTransformation:s}=e,{pyramidLevel:n,pyramidResolution:a,excessiveReading:l}=Ae(i,this.rasterInfo,this.ioConfig.sampling);if(l)return;let o=e.srcExtent||Re(t,r,s);if(o==null)return;const c=U(this.rasterInfo.transform);c&&(o=c.inverseTransform(o)),e.srcExtent=o;const u=Math.ceil((o.xmax-o.xmin)/a.x-.1),f=Math.ceil((o.ymax-o.ymin)/a.y-.1);e.pyramidLevel=n,e.pyramidResolution=a,e.srcWidth=u,e.srcHeight=f}_getRequestOptionsWithSliceId(t){return k(this.rasterInfo.multidimensionalInfo)&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,e){const{srcLocation:r,position:i,pyramidLevel:s,useTransposedTile:n}=e,a=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[i]))return{location:r,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(M(l)||!n){const h=t.pixels.map(m=>m[i]),y={location:r,value:h,pyramidLevel:s},p=this._computeMagDirValues(h.map(m=>[m]));return p!=null&&p.length&&(y.magdirValue=p.map(m=>m[0])),y}let o=t.pixels.map(h=>Array.prototype.slice.call(h,i*a,i*a+a)),c=this._computeMagDirValues(o);const{requestSomeSlices:u,identifyOptions:f}=e;let d=Wt(l,f.transposedVariableName);if(u){const h=jt(d,U(f.multidimensionalDefinition),U(f.timeExtent));o=o.map(y=>h.map(p=>y[p])),c=c==null?void 0:c.map(y=>h.map(p=>y[p])),d=h.map(y=>d[y])}return{location:r,value:null,dataSeries:d.map((h,y)=>{const p={value:o.map(m=>m[y]),multidimensionalDefinition:h.multidimensionalDefinition.map(m=>new et({...m,isSlice:!0}))};return c!=null&&c.length&&(p.magdirValue=[c[0][y],c[1][y]]),p}),pyramidLevel:s}}};w([b()],q.prototype,"_rasterTileAlighmentInfo",void 0),w([b({readOnly:!0})],q.prototype,"_isGlobalWrappableSource",null),w([b(Xe)],q.prototype,"url",null),w([b({type:String,json:{write:!0}})],q.prototype,"datasetName",void 0),w([b({type:String,json:{write:!0}})],q.prototype,"datasetFormat",void 0),w([b()],q.prototype,"rasterInfo",void 0),w([b()],q.prototype,"ioConfig",void 0),w([b()],q.prototype,"sourceJSON",void 0),q=w([K("esri.layers.support.rasterDatasets.BaseRaster")],q);const ie=q;let se=class extends ie{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._primaryRasters=null}async open(e){await this.init();const{rasterFunction:r}=this,{rasters:i,rasterIds:s}=r.getPrimaryRasters(),n=i.map(o=>o.rasterInfo?void 0:o.open(e));await Promise.all(n);const a=i.map(({rasterInfo:o})=>o),l=r.bind({rasterInfos:a,rasterIds:s});if(!l.success)throw new $("raster-function:open",`cannot bind the function: ${l.error??""}`);await this.syncJobHandler(),this.set("sourceJSON",i[0].sourceJSON),this.set("rasterInfo",r.rasterInfo)}async syncJobHandler(){const{rasterFunction:e}=this;if(this._primaryRasters=e.getPrimaryRasters(),this.rasterJobHandler)return this.rasterJobHandler.updateRasterFunction(e)}async fetchPixels(e,r,i,s={}){var d;const{rasters:n,rasterIds:a}=this._primaryRasters,l=n.map(h=>h.fetchPixels(e,r,i,s)),o=await Promise.all(l),c=o.map(h=>h.pixelBlock);if(c.every(h=>M(h)))return o[0];const u=((d=o.find(h=>k(h.pixelBlock)))==null?void 0:d.extent)??e,f=this.rasterJobHandler?await this.rasterJobHandler.process({extent:u,primaryPixelBlocks:c,primaryRasterIds:a}):this.rasterFunction.process({extent:u,primaryPixelBlocks:c,primaryRasterIds:a});return{...o[0],pixelBlock:f}}};w([b({type:String,json:{write:!0}})],se.prototype,"datasetFormat",void 0),w([b()],se.prototype,"tileType",void 0),w([b()],se.prototype,"rasterFunction",void 0),se=w([K("esri.layers.support.rasterDatasets.FunctionRaster")],se);const it=se,We=Ue.getLogger("esri.layers.mixins.ImageryTileMixin"),vi=t=>{let e=class extends t{constructor(){super(...arguments),this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalDefinition=null,this.multidimensionalSubset=null,this.raster=null,this.rasterFunction=null,this.sourceJSON=null,this.symbolizer=null}get fullExtent(){var i;return(i=this.rasterInfo)==null?void 0:i.extent}get rasterInfo(){var i;return(i=this.raster)==null?void 0:i.rasterInfo}get spatialReference(){var i;return((i=this.rasterInfo)==null?void 0:i.spatialReference)??J.WGS84}get tileInfo(){var i;return(i=this.rasterInfo)==null?void 0:i.storageInfo.tileInfo}set url(i){this._set("url",qe(i,We))}set renderer(i){this._set("renderer",i),this.updateRenderer()}async convertVectorFieldData(i,s){if(M(i)||!this.rasterInfo)return null;const n=this._rasterJobHandler.instance,a=this.rasterInfo.dataType;return n?n.convertVectorFieldData({pixelBlock:i,dataType:a},s):yi(i,a)}async createFlowMesh(i,s){const n=this._rasterJobHandler.instance;return n?n.createFlowMesh(i,s):gi(i.meshType,i.simulationSettings,i.flowData,k(s.signal)?s.signal:new AbortController().signal)}normalizeRasterFetchOptions(i){var l,o;const{multidimensionalInfo:s}=this.rasterInfo??{};if(M(s))return i;let n=i.multidimensionalDefinition||this.multidimensionalDefinition;!M(n)&&n.length||(n=De(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset}));const a=i.timeExtent||this.timeExtent;if(k(n)&&k(a)&&(k(a.start)||k(a.end))){n=n.map(g=>g.clone());const c=(o=(l=s.variables.find(({name:g})=>g===n[0].variableName))==null?void 0:l.dimensions)==null?void 0:o.find(({name:g})=>g==="StdTime"),u=n.find(({dimensionName:g})=>g==="StdTime");if(!c||!u)return{...i,multidimensionalDefinition:null};const{start:f,end:d}=a,h=M(f)?null:f.getTime(),y=M(d)?null:d.getTime(),p=h??y,m=y??h;if(k(c.values)){const g=c.values.filter(x=>{if(Array.isArray(x)){if(p===m)return x[0]<=p&&x[1]>=p;const I=x[0]<=p&&x[1]>p||x[0]<m&&x[1]>=m,C=x[0]>=p&&x[1]<=m||x[0]<p&&x[1]>m;return I||C}return p===m?x===p:x>=p&&x<=m});if(g.length){const x=g.sort((I,C)=>p===m?(I[0]??I)-(C[0]??C):Math.abs((I[1]??I)-m)-Math.abs((C[1]??C)-m))[0];u.values=[x]}else n=null}else if(c.hasRegularIntervals&&c.extent){const[g,x]=c.extent;p>x||m<g?n=null:u.values=p===m?[p]:[Math.max(g,p),Math.min(x,m)]}}return k(n)&&Gt(n,this.multidimensionalSubset)?{...i,multidimensionalDefinition:null}:{...i,multidimensionalDefinition:n}}async updateRenderer(){const{loaded:i,symbolizer:s}=this;if(!i||!s||JSON.stringify(this._cachedRendererJson)===JSON.stringify(this.renderer))return;const n=this._rasterJobHandler.instance;n&&(s.rendererJSON=Be(this.renderer.toJSON()),s.bind(),await n.updateSymbolizer(s),this._cachedRendererJson=this.renderer.toJSON())}async applyRenderer(i,s){const n=i&&i.pixelBlock;if(!(k(n)&&n.pixels&&n.pixels.length>0))return null;let a;await this.updateRenderer();const l=this._rasterJobHandler.instance,o=this.bandIds??[];return a=l?await l.symbolize({...i,simpleStretchParams:s,bandIds:o}):this.symbolizer.symbolize({...i,simpleStretchParams:s,bandIds:o}),a}getTileUrl(i,s,n){var a;return((a=this.raster)==null?void 0:a.datasetFormat)==="RasterTileServer"?`${this.url}/tile/${i}/${s}/${n}`:""}getCompatibleTileInfo(i,s,n=!1){if(!this.loaded||M(s))return null;if(n&&i.equals(this.spatialReference))return this.tileInfo;const a=ut(i);return fe.create({size:256,spatialReference:i,origin:a?{x:a.origin[0],y:a.origin[1]}:{x:s.xmin,y:s.ymax}})}getCompatibleFullExtent(i){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(i)||(this._compatibleFullExtent=this.raster.computeExtent(i)),this._compatibleFullExtent):null}async fetchTile(i,s,n,a={}){if(r(this),a.requestAsImageElement){const l=this.getTileUrl(i,s,n);return Ve(l,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:a.signal}).then(o=>o.data)}if(k(this.rasterInfo.multidimensionalInfo)&&(a=this.normalizeRasterFetchOptions(a),M(a.multidimensionalDefinition))){const l=a.tileInfo||this.rasterInfo.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(i,s,n,l),pixelBlock:null}}return await this._initJobHandler(),await this._updateRasterFunction(),this.renderer.type==="raster-shaded-relief"&&(a={...a,buffer:{cols:1,rows:1}}),this.raster.fetchTile(i,s,n,a)}async fetchPixels(i,s,n,a={}){return k(this.rasterInfo.multidimensionalInfo)&&(a=this.normalizeRasterFetchOptions(a),M(a.multidimensionalDefinition))?{extent:i,pixelBlock:null}:(await this._initJobHandler(),await this._updateRasterFunction(),this.raster.fetchPixels(i,s,n,a))}async identify(i,s={}){return r(this),k(this.rasterInfo.multidimensionalInfo)&&!(this.rasterInfo.hasMultidimensionalTranspose&&(Ze(s.multidimensionalDefinition)||s.transposedVariableName||s.timeExtent))&&(s=this.normalizeRasterFetchOptions(s),M(s.multidimensionalDefinition))?{location:i,value:null}:this.raster.identify(i,s)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){var a,l,o;const i=(a=this.rasterInfo)==null?void 0:a.multidimensionalInfo;if(M(i)||((l=this.rasterInfo)==null?void 0:l.dataType)!=="standard-time")return!1;const s=this.multidimensionalDefinition,n=(o=s==null?void 0:s[0])==null?void 0:o.variableName;return i.variables.some(c=>c.name===n&&(!(s!=null&&s[0].dimensionName)||c.dimensions.some(u=>u.name==="StdTime")))}getStandardTimeValue(i){return new Date(24*(i-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(i){const s=i??this.rasterInfo.multidimensionalInfo;return qt(this.multidimensionalSubset,s)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=De(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this._configDefaultRenderer()}_initJobHandler(){if(this._rasterJobHandler.connectionPromise!=null)return this._rasterJobHandler.connectionPromise;const i=new zt;return this._rasterJobHandler.connectionPromise=i.initialize().then(()=>{r(this),this._rasterJobHandler.instance=i,this.raster.rasterJobHandler=i,this.renderer&&this.updateRenderer(),this.raster.datasetFormat==="Function"&&this.raster.syncJobHandler()}).catch(()=>{}),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){var i;if(this.interpolation==null){r(this);const s=Bt(this.rasterInfo,this.raster.tileType,(i=this.sourceJSON)==null?void 0:i.defaultResamplingMethod);this._set("interpolation",s)}}_configDefaultRenderer(){var n,a,l;r(this);const i=this.raster.rasterInfo;if(this.bandIds||(this.bandIds=Dt(i)),!this.renderer){const o=Et(i,{bandIds:this.bandIds,variableName:k(this.multidimensionalDefinition)?(n=this.multidimensionalDefinition[0])==null?void 0:n.variableName:null});this.raster.datasetFormat==="WCSServer"&&o.type==="raster-stretch"&&((((a=i.statistics)==null?void 0:a[0].max)??0)>1e24||(((l=i.statistics)==null?void 0:l[0].min)??0)<-1e24)&&(o.dynamicRangeAdjustment=!0,o.statistics=null,o.stretchType==="none"&&(o.stretchType="min-max")),this.renderer=o}this.symbolizer?(this.symbolizer.rendererJSON=Be(this.renderer.toJSON()),this.symbolizer.rasterInfo=i):this.symbolizer=new Vt({rendererJSON:this.renderer.toJSON(),rasterInfo:i});const s=this.symbolizer.bind();s.success||We.warn("imagery-tile-mixin",s.error||"The given renderer is not supported by the layer.")}async _updateRasterFunction(){var n;if(this.type!=="imagery-tile"||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;let i=this.raster;(i==null?void 0:i.datasetFormat)==="Function"&&(i=i.rasterFunction.getPrimaryRasters().rasters[0]);const{rasterFunction:s}=this;if(s){const a=tt(s.toJSON(),{raster:i}),l=new it({rasterFunction:a});l.rasterJobHandler=this._rasterJobHandler.instance,await l.open(),this._cachedRasterFunctionJson=(n=this.rasterFunction)==null?void 0:n.toJSON(),this.raster=l}else this.raster=i}};function r(i){if(!i.raster||!i.rasterInfo)throw new $("imagery-tile","no raster")}return w([b()],e.prototype,"_cachedRendererJson",void 0),w([b()],e.prototype,"_cachedRasterFunctionJson",void 0),w([b()],e.prototype,"_compatibleFullExtent",void 0),w([b()],e.prototype,"_rasterJobHandler",void 0),w([b()],e.prototype,"bandIds",void 0),w([b({json:{origins:{service:{read:{source:"copyrightText"}}}}})],e.prototype,"copyright",void 0),w([b({json:{read:!1}})],e.prototype,"fullExtent",null),w([b()],e.prototype,"interpolation",void 0),w([b()],e.prototype,"ioConfig",void 0),w([b({type:[et]})],e.prototype,"multidimensionalDefinition",void 0),w([b({type:$t,json:{write:!0}})],e.prototype,"multidimensionalSubset",void 0),w([b()],e.prototype,"raster",void 0),w([b({type:Ot})],e.prototype,"rasterFunction",void 0),w([b()],e.prototype,"rasterInfo",null),w([b()],e.prototype,"sourceJSON",void 0),w([b({json:{read:!1}})],e.prototype,"spatialReference",null),w([b({json:{read:!1}})],e.prototype,"tileInfo",null),w([b(Xe)],e.prototype,"url",null),w([b({types:Qe})],e.prototype,"renderer",null),w([b()],e.prototype,"symbolizer",void 0),e=w([K("esri.layers.ImageryTileMixin")],e),e};function Ti(t){const e=t.fields,r=t.records,i=e.some(c=>c.name.toLowerCase()==="oid")?"OBJECTID":"OID",s=[{name:i,type:"esriFieldTypeOID",alias:"OID"}].concat(e.map(c=>({name:c.name,type:"esriFieldType"+c.typeName,alias:c.name}))),n=s.map(c=>c.name),a=[];let l=0,o=0;return r.forEach(c=>{const u={};for(u[i]=l++,o=1;o<n.length;o++)u[n[o]]=c[o-1];a.push({attributes:u})}),{displayFieldName:"",fields:s,features:a}}class st{static get supportedVersions(){return[5]}static parse(e){const r=new DataView(e),i=3&r.getUint8(0);if(i!==3)return{header:{version:i},recordSet:null};const s=r.getUint32(4,!0),n=r.getUint16(8,!0),a=r.getUint16(10,!0),l={version:i,recordCount:s,headerByteCount:n,recordByteCount:a};let o=32;const c=[],u=[];let f;if(i===3){for(;r.getUint8(o)!==13;)f=String.fromCharCode(r.getUint8(o+11)).trim(),c.push({name:Ee(new Uint8Array(e,o,11)),type:f,typeName:["String","Date","Double","Boolean","String","Integer"][["C","D","F","L","M","N"].indexOf(f)],length:r.getUint8(o+16)}),o+=32;if(o+=1,c.length>0)for(;u.length<s&&e.byteLength-o>a;){const d=[];r.getUint8(o)===32?(o+=1,c.forEach(h=>{if(h.type==="C")d.push(Ee(new Uint8Array(e,o,h.length)).trim());else if(h.type==="N")d.push(parseInt(String.fromCharCode.apply(null,new Uint8Array(e,o,h.length)).trim(),10));else if(h.type==="F")d.push(parseFloat(String.fromCharCode.apply(null,new Uint8Array(e,o,h.length)).trim()));else if(h.type==="D"){const y=String.fromCharCode.apply(null,new Uint8Array(e,o,h.length)).trim();d.push(new Date(parseInt(y.substring(0,4),10),parseInt(y.substring(4,6),10)-1,parseInt(y.substring(6,8),10)))}o+=h.length}),u.push(d)):o+=a}}return{header:l,fields:c,records:u,recordSet:Ti({fields:c,records:u})}}}const Z=new Map;Z.set("int16","esriFieldTypeSmallInteger"),Z.set("int32","esriFieldTypeInteger"),Z.set("int64","esriFieldTypeInteger"),Z.set("float32","esriFieldTypeSingle"),Z.set("float64","esriFieldTypeDouble"),Z.set("text","esriFieldTypeString");const je=8;let le=class extends ie{constructor(){super(...arguments),this.storageInfo=null,this.datasetFormat="CRF"}async open(t){await this.init();const{data:e}=await this.request(this.url+"/conf.json",{signal:t==null?void 0:t.signal});if(!this._validateHeader(e))throw new $("cloudraster:open","Invalid or unsupported conf.json.");this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const{storageInfo:r,rasterInfo:i}=this._parseHeader(e);if(i.dataType==="thematic"){const s=await this._fetchAuxiliaryInformation();i.attributeTable=s}this._set("storageInfo",r),this._set("rasterInfo",i),this.ioConfig.retryCount=this.ioConfig.retryCount||0}async fetchRawTile(t,e,r,i={}){const{transposeInfo:s}=this.rasterInfo.storageInfo,{transposedVariableName:n}=i,a=!(!s||!n),l=a?0:this.rasterInfo.storageInfo.maximumPyramidLevel-t;if(l<0)return null;const o=this._buildCacheFilePath(l,e,r,i.multidimensionalDefinition,n),c=this._getIndexRecordFromBundle(e,r,a),u=await this.request(o,{range:{from:0,to:this.storageInfo.headerSize-1},responseType:"array-buffer",signal:i.signal});if(!u)return null;const f=new Uint8Array(u.data),d=this._getTileEndAndContentType(f,c);if(d.recordSize===0)return null;const h=await this.request(o,{range:{from:d.position,to:d.position+d.recordSize},responseType:"array-buffer",signal:i.signal});if(!h)return null;const[y,p]=this._getTileSize(a);return this.decodePixelBlock(h.data,{width:y,height:p,planes:null,pixelType:null,returnInterleaved:a})}_validateHeader(t){const e=["origin","extent","geodataXform","LODInfos","blockWidth","blockHeight","bandCount","pixelType","pixelSizeX","pixelSizeY","format","packetSize"];return t&&t.type==="RasterInfo"&&!e.some(r=>!t[r])}_parseHeader(t){var V;const e=["u1","u2","u4","u8","s8","u16","s16","u32","s32","f32","f64"][t.pixelType],{bandCount:r,histograms:i,colormap:s,blockWidth:n,blockHeight:a,firstPyramidLevel:l,maximumPyramidLevel:o}=t,c=t.statistics&&t.statistics.map(D=>({min:D.min,max:D.max,avg:D.mean,stddev:D.standardDeviation,median:D.median,mode:D.mode})),u=t.extent.spatialReference,f=(V=t.geodataXform)==null?void 0:V.spatialReference,d=new J(u!=null&&u.wkid||u!=null&&u.wkt?u:f);let h=new W({xmin:t.extent.xmin,ymin:t.extent.ymin,xmax:t.extent.xmax,ymax:t.extent.ymax,spatialReference:d});const y=new N({x:t.pixelSizeX,y:t.pixelSizeY,spatialReference:d}),p=Math.round((h.xmax-h.xmin)/y.x),m=Math.round((h.ymax-h.ymin)/y.y),g=this._parseTransform(t.geodataXform),x=g?h:null;g&&(h=g.forwardTransform(h),y.x=(h.xmax-h.xmin)/p,y.y=(h.ymax-h.ymin)/m);const I=t.properties??{},C=t.format.toLowerCase().replace("cache/",""),P=new N(t.origin.x,t.origin.y,d);let T,v,R,S;if(s&&s.colors)for(T=[],v=0;v<s.colors.length;v++)R=s.colors[v],S=s.values?s.values[v]:v,T.push([S,255&R,R<<16>>>24,R<<8>>>24,R>>>24]);const _=t.LODInfos,F=[];for(v=0;v<_.levels.length;v++)F.push({level:_.levels[v],resolution:_.resolutions[v],scale:96/.0254*_.resolutions[v]});const E=new fe({dpi:96,lods:F,format:C,origin:P,size:[n,a],spatialReference:d}),j={recordSize:je,packetSize:t.packetSize,headerSize:t.packetSize*t.packetSize*je+64},H=[{maxCol:Math.ceil(p/n)-1,maxRow:Math.ceil(m/a)-1,minCol:0,minRow:0}];let B=2;if(o>0)for(v=0;v<o;v++)H.push({maxCol:Math.ceil(p/B/n)-1,maxRow:Math.ceil(m/B/a)-1,minCol:0,minRow:0}),B*=2;const L=t.mdInfo;let G=null;if(L&&I._yxs){const D=I._yxs;G={packetSize:D.PacketSize,tileSize:[D.TileXSize,D.TileYSize]}}return{storageInfo:j,rasterInfo:new me({width:p,height:m,pixelType:e,bandCount:r,extent:h,nativeExtent:x,transform:g,spatialReference:d,pixelSize:y,keyProperties:I,statistics:c,histograms:i,multidimensionalInfo:L,colormap:T,storageInfo:new de({blockWidth:n,blockHeight:a,pyramidBlockWidth:n,pyramidBlockHeight:a,origin:P,tileInfo:E,transposeInfo:G,firstPyramidLevel:l,maximumPyramidLevel:o,blockBoundary:H})})}}_parseTransform(t){var r,i;if(!xi(t))throw new $("cloudraster:open","the data contains unsupported geodata transform types");const e=Ii(t);if(e.type==="identity")return null;if(e.type!=="polynomial"||!((r=e.forwardCoefficients)!=null&&r.length)||!((i=e.inverseCoefficients)!=null&&i.length))throw new $("cloudraster:open","the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");return e}async _fetchAuxiliaryInformation(t){const e=this.request(this.url+"/conf.vat.json",{signal:t}).then(n=>n.data).catch(()=>null),r=this.request(this.url+"/conf.vat.dbf",{responseType:"array-buffer",signal:t}).then(n=>n.data).catch(()=>null),i=await Promise.all([e,r]);let s;if(i[0]){let n=i[0].fields;const a=i[0].values;if(n&&a){n=n.map(o=>({type:o.name==="OID"?"esriFieldTypeOID":Z.get(o.type),name:o.name,alias:o.alias||o.name}));const l=a.map(o=>({attributes:o}));n&&a&&(s={fields:n,features:l})}}return!s&&i[1]&&(s=st.parse(i[1]).recordSet),Ye.fromJSON(s)}_buildCacheFilePath(t,e,r,i,s){const n=this._getPackageSize(!!s),a=Math.floor(e/n)*n,l=Math.floor(r/n)*n,o="R"+this._toHexString4(a)+"C"+this._toHexString4(l);let c="L";c+=t>=10?t.toString():"0"+t.toString();const{multidimensionalInfo:u}=this.rasterInfo,f=i==null?void 0:i[0];if(M(u)||!f)return`${this.url}/_alllayers/${c}/${o}.bundle`;let d="_yxs";if(!s){d=u.variables.find(p=>p.name===f.variableName).dimensions[0].values.indexOf(f.values[0]).toString(16);const y=4-d.length;for(let p=0;p<y;p++)d="0"+d;d="S"+d}const h=this._getVariableFolderName(s||f.variableName);return`${this.url}/_alllayers/${h}/${d}/${c}/${o}.bundle`}_getPackageSize(t=!1){const{transposeInfo:e}=this.rasterInfo.storageInfo;return t&&k(e)?e.packetSize??0:this.storageInfo.packetSize}_getTileSize(t=!1){const{storageInfo:e}=this.rasterInfo,{transposeInfo:r}=e;return t&&k(r)?r.tileSize:e.tileInfo.size}_getVariableFolderName(t){return(t=t.trim())===""?"_v":t.replace(/[\{|\}\-]/g,"_").replace("\\*","_v")}_getIndexRecordFromBundle(t,e,r=!1){const i=this._getPackageSize(r),s=i*(t%i)+e%i;if(s<0)throw"Invalid level / row / col";return 20+s*this.storageInfo.recordSize+44}_getTileEndAndContentType(t,e){const r=t.subarray(e,e+8);let i,s=0;for(i=0;i<5;i++)s|=(255&r[i])<<8*i;const n=0xffffffffff&s;for(s=0,i=5;i<8;i++)s|=(255&r[i])<<8*(i-5);return{position:n,recordSize:0xffffffffff&s}}_toHexString4(t){let e=t.toString(16);if(e.length!==4){let r=4-e.length;for(;r-- >0;)e="0"+e}return e}};w([b({readOnly:!0})],le.prototype,"storageInfo",void 0),w([b({type:String,json:{write:!0}})],le.prototype,"datasetFormat",void 0),le=w([K("esri.layers.support.rasterDatasets.CloudRaster")],le);const Ri=le;let ce=class extends ie{constructor(){super(...arguments),this.datasetFormat="MEMORY",this.data=null}async open(t){await this.init();const e=this.data,{pixelBlock:r,statistics:i,histograms:s,name:n,keyProperties:a,nativeExtent:l,transform:o}=this.data,{width:c,height:u,pixelType:f}=r,d=e.extent??new W({xmin:-.5,ymin:.5,xmax:c-.5,ymax:u-.5,spatialReference:new J({wkid:3857})}),h=e.isPseudoSpatialReference??!e.extent,y={x:d.width/c,y:d.height/u},p=new me({width:c,height:u,pixelType:f,extent:d,nativeExtent:l,transform:o,pixelSize:y,spatialReference:d.spatialReference,bandCount:3,keyProperties:a||{},statistics:i,isPseudoSpatialReference:h,histograms:s});this.createRemoteDatasetStorageInfo(p,512,512),this._set("rasterInfo",p),this.updateTileInfo(),await this._buildInMemoryRaster(r,{width:512,height:512},t),this.datasetName=n,this.url="/InMemory/"+n}fetchRawTile(t,e,r,i={}){const s=this._pixelBlockTiles.get(`${t}/${e}/${r}`);return Promise.resolve(s)}async _buildInMemoryRaster(t,e,r){var c,u;const i=this.rasterInfo.storageInfo.maximumPyramidLevel,s=this.rasterJobHandler?this.rasterJobHandler.split({pixelBlock:t,tileSize:e,maximumPyramidLevel:i},r):Promise.resolve(oi(t,e,i)),n=k(this.rasterInfo.statistics),a=k(this.rasterInfo.histograms),l=n?Promise.resolve({statistics:null,histograms:null}):this.rasterJobHandler?this.rasterJobHandler.estimateStatisticsHistograms({pixelBlock:t},r):Promise.resolve(Xt(t)),o=await Ke([s,l]);if(!o[0].value&&o[1].value)throw new $("inmemory-raster:open","failed to build in memory raster");this._pixelBlockTiles=o[0].value,n||(this.rasterInfo.statistics=(c=o[1].value)==null?void 0:c.statistics),a||(this.rasterInfo.histograms=(u=o[1].value)==null?void 0:u.histograms)}};w([b({type:String,json:{write:!0}})],ce.prototype,"datasetFormat",void 0),w([b()],ce.prototype,"data",void 0),ce=w([K("esri.layers.support.rasterDatasets.InMemoryRaster")],ce);const _i=ce;function ne(t,e){if(!t||!e)return[];let r=e;e.includes("/")?(r=e.slice(0,e.indexOf("/")),e=e.slice(e.indexOf("/")+1)):e="";const i=[];if(e){const n=ne(t,r);for(let a=0;a<n.length;a++)ne(n[a],e).forEach(l=>i.push(l));return i}const s=t.getElementsByTagNameNS("*",r);if(!s||s.length===0)return[];for(let n=0;n<s.length;n++)i.push(s[n]||s.item[n]);return i}function A(t,e){if(!t||!e)return null;let r=e;e.includes("/")?(r=e.slice(0,e.indexOf("/")),e=e.slice(e.indexOf("/")+1)):e="";const i=ne(t,r);return i.length>0?e?A(i[0],e):i[0]:null}function Y(t,e=null){const r=e?A(t,e):t;let i;return r?(i=r.textContent||r.nodeValue,i?i.trim():null):null}function ki(t,e){const r=ne(t,e),i=[];let s;for(let n=0;n<r.length;n++)s=r[n].textContent||r[n].nodeValue,s&&(s=s.trim(),s!==""&&i.push(s));return i}function Ie(t,e){return ki(t,e).map(r=>Number(r))}function te(t,e){const r=Y(t,e);return Number(r)}function _e(t,e){var s;const r=(s=t==null?void 0:t.nodeName)==null?void 0:s.toLowerCase(),i=e.toLowerCase();return r.slice(r.lastIndexOf(":")+1)===i}function Ge(t,e){if(!t||!e)return null;const r=[];for(let i=0;i<t.length;i++)r.push(t[i]),r.push(e[i]);return r}function Ci(t){const e=A(t,"GeodataXform"),r=Se(te(e,"SpatialReference/WKID")||Y(e,"SpatialReference/WKT"));if(e.getAttribute("xsi:type")!=="typens:PolynomialXform")return{spatialReference:r,transform:null};const i=te(e,"PolynomialOrder")??1,s=Ie(e,"CoeffX/Double"),n=Ie(e,"CoeffY/Double"),a=Ie(e,"InverseCoeffX/Double"),l=Ie(e,"InverseCoeffY/Double"),o=Ge(s,n),c=Ge(a,l);return{spatialReference:r,transform:o&&c&&o.length&&c.length?new Fe({spatialReference:r,polynomialOrder:i,forwardCoefficients:o,inverseCoefficients:c}):null}}function Pi(t){var d;const e=te(t,"NoDataValue"),r=A(t,"Histograms/HistItem"),i=te(r,"HistMin"),s=te(r,"HistMax"),n=te(r,"BucketCount"),a=(d=Y(r,"HistCounts"))==null?void 0:d.split("|").map(h=>Number(h));let l,o,c,u;ne(t,"Metadata/MDI").forEach(h=>{const y=Number(h.textContent??h.nodeValue);switch(h.getAttribute("key").toUpperCase()){case"STATISTICS_MINIMUM":l=y;break;case"STATISTICS_MAXIMUM":o=y;break;case"STATISTICS_MEAN":c=y;break;case"STATISTICS_STDDEV":u=y}});const f=te(t,"Metadata/SourceBandIndex");return{noDataValue:e,histogram:a!=null&&a.length&&i!=null&&s!=null?{min:i,max:s,size:n||a.length,counts:a}:null,sourceBandIndex:f,statistics:l!=null&&o!=null?{min:l,max:o,avg:c,stddev:u}:null}}function Se(t){if(!t)return null;let e=Number(t);if(!isNaN(e)&&e!==0)return new J({wkid:e});if((t=String(t)).startsWith("COMPD_CS")){if(!t.includes("VERTCS")||!t.includes("GEOGCS")&&!t.startsWith("PROJCS"))return null;const r=t.indexOf("VERTCS"),i=t.indexOf("PROJCS"),s=i>-1?i:t.indexOf("GEOGCS");if(s===-1)return null;const n=t.slice(s,t.lastIndexOf("]",r)+1).trim(),a=t.slice(r,t.lastIndexOf("]")).trim();e=ke(n);const l=new J(e?{wkid:e}:{wkt:n}),o=ke(a);return o&&(l.vcsWkid=o),l}return t.startsWith("GEOGCS")||t.startsWith("PROJCS")?(e=ke(t),new J(e!==0?{wkid:e}:{wkt:t})):null}function ke(t){var s;const e=t.replace(/\]/g,"[").replace(/\"/g,"").split("[").map(n=>n.trim()).filter(n=>n!==""),r=e[e.length-1].split(","),i=(s=r[0])==null?void 0:s.toLowerCase();if((i==="epsg"||i==="esri")&&t.endsWith('"]]')){const n=Number(r[1]);if(!isNaN(n)&&n!==0)return n}return 0}function Me(t){var i;if(((i=t==null?void 0:t.documentElement.tagName)==null?void 0:i.toLowerCase())!=="pamdataset")return{};const e={spatialReference:null,transform:null,metadata:{},rasterBands:[],statistics:null,histograms:null};t.documentElement.childNodes.forEach(s=>{if(s.nodeType===1){if(_e(s,"SRS")){if(!e.spatialReference){const n=Y(s);e.spatialReference=Se(n)}}else if(_e(s,"Metadata"))if(s.getAttribute("domain")==="xml:ESRI"){const{spatialReference:n,transform:a}=Ci(s);e.transform=a,e.spatialReference||(e.spatialReference=n)}else ne(s,"MDI").forEach(n=>e.metadata[n.getAttribute("key")]=Y(n));else if(_e(s,"PAMRasterBand")){const n=Pi(s);n.sourceBandIndex!=null&&e.rasterBands[n.sourceBandIndex]==null?e.rasterBands[n.sourceBandIndex]=n:e.rasterBands.push(n)}}});const r=e.rasterBands;if(r.length){const s=!!r[0].statistics;e.statistics=s?r.map(a=>a.statistics).filter(k):null;const n=!!r[0].histogram;e.histograms=n?r.map(a=>a.histogram).filter(k):null}return e}let be=class extends ie{async open(t){await this.init();const e=await this._fetchData(t);let{spatialReference:r,statistics:i,histograms:s,transform:n}=await this._fetchAuxiliaryData(t);const a=!r;a&&(r=new J({wkid:3857})),s!=null&&s.length&&i==null&&(i=Pe(s));const{width:l,height:o}=e;let c=new W({xmin:-.5,ymin:.5-o,xmax:l-.5,ymax:.5,spatialReference:r});const u=n?n.forwardTransform(c):c;let f=!0;if(n){const h=n.forwardCoefficients;f=h&&h[1]===0&&h[2]===0,f&&(n=null,c=u)}const d=new _i({data:{extent:u,nativeExtent:c,transform:n,pixelBlock:e,statistics:i,histograms:s,keyProperties:{DateType:"Processed"},isPseudoSpatialReference:a}});await d.open(),d.data=null,this._set("rasterInfo",d.rasterInfo),this._inMemoryRaster=d}fetchRawTile(t,e,r,i={}){return this._inMemoryRaster.fetchRawTile(t,e,r,i)}async _fetchData(t){const{data:e}=await this.request(this.url,{responseType:"array-buffer",signal:t==null?void 0:t.signal}),r=Yt(e).toUpperCase();if(r!=="JPG"&&r!=="PNG"&&r!=="GIF"&&r!=="BMP")throw new $("image-aux-raster:open","the data is not a supported format");this._set("datasetFormat",r);const i=r.toLowerCase(),s=i==="gif"||i==="bmp"||!ht("ios");return await this.decodePixelBlock(e,{format:i,useCanvas:s,hasNoZlibMask:!0})}async _fetchAuxiliaryData(t){var c;const e=U(t==null?void 0:t.signal),r=this.ioConfig.skipExtensions??[],i=r.includes("aux.xml")?null:this.request(this.url+".aux.xml",{responseType:"xml",signal:e}),s=this.datasetFormat,n=s==="JPG"?"jgw":s==="PNG"?"pgw":s==="BMP"?"bpw":null,a=n&&r.includes(n)?null:this.request(this.url.slice(0,this.url.lastIndexOf("."))+"."+n,{responseType:"text",signal:e}),l=await Ke([i,a]);if(e!=null&&e.aborted)throw ft();const o=Me((c=l[0].value)==null?void 0:c.data);if(!o.transform){const u=l[1].value?l[1].value.data.split(`
`).slice(0,6).map(f=>Number(f)):null;o.transform=(u==null?void 0:u.length)===6?new Fe({forwardCoefficients:[u[4],u[5],u[0],-u[1],u[2],-u[3]]}):null}return o}};w([b({type:String,json:{write:!0}})],be.prototype,"datasetFormat",void 0),be=w([K("esri.layers.support.rasterDatasets.ImageAuxRaster")],be);const we=be;let ue=class extends ie{constructor(){super(...arguments),this._levelOffset=0,this._tilemapCache=null,this._slices=null,this.datasetFormat="RasterTileServer",this.tileType=null}async open(e){var T,v;await this.init();const r=e&&e.signal,i=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:r});i.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));const s=i.data;if(this.sourceJSON=s,!s)throw new $("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!s.tileInfo)throw new $("imageserverraster:open","use ImageryLayer to open non-tiled image services");this._fixScaleInServiceInfo();const n=["jpg","jpeg","png","png8","png24","png32","mixed"];this.tileType=s.cacheType,this.tileType==null&&(n.includes(s.tileInfo.format.toLowerCase())?this.tileType="Map":s.tileInfo.format.toLowerCase()==="lerc"?this.tileType="Elevation":this.tileType="Raster"),this.datasetName=((T=s.name)==null?void 0:T.slice(s.name.indexOf("/")+1))??"";const a=await this._fetchRasterInfo({signal:r});if(M(a))throw new $("image-server-raster:open","cannot initialize image service");const l=this.tileType==="Map"?bi(s.tileInfo,s):fe.fromJSON(s.tileInfo);dt(l);const[o,c]=this._computeMinMaxLOD(a,l),{extent:u,pixelSize:f}=a,d=.5/a.width*f.x,h=Math.max(f.x,f.y),{lods:y}=l;(this.tileType!=="Map"&&s.maxScale!==0||Math.abs(f.x-f.y)>d||!y.some(R=>Math.abs(R.resolution-h)<d))&&(f.x=f.y=o.resolution,a.width=Math.ceil((u.xmax-u.xmin)/f.x-.1),a.height=Math.ceil((u.ymax-u.ymin)/f.y-.1));const p=o.level-c.level,[m,g]=l.size,x=[];y.forEach(R=>{R.level>=c.level&&R.level<=o.level&&x.push({x:R.resolution,y:R.resolution})}),x.sort((R,S)=>R.x-S.x);const I=this.computeBlockBoundary(u,m,g,l.origin,x,p),C=x.length>1?x.slice(1):null;let P;if(s.transposeInfo&&(P={tileSize:[s.transposeInfo.rows,s.transposeInfo.cols],packetSize:((v=a.keyProperties)==null?void 0:v._yxs.PacketSize)??0}),a.storageInfo=new de({blockWidth:l.size[0],blockHeight:l.size[1],pyramidBlockWidth:l.size[0],pyramidBlockHeight:l.size[1],pyramidResolutions:C,compression:l.format,origin:l.origin,firstPyramidLevel:1,maximumPyramidLevel:p,tileInfo:l,transposeInfo:P,blockBoundary:I}),this._fixGCSShift(a),this._set("rasterInfo",a),s.capabilities.toLowerCase().includes("tilemap")){const R={tileInfo:a.storageInfo.tileInfo,parsedUrl:mt(this.url),url:this.url,tileServers:[],type:"tile"};this._tilemapCache=new Si({layer:R})}}async fetchRawTile(e,r,i,s={}){const{storageInfo:n,extent:a}=this.rasterInfo,{transposeInfo:l}=n,o=k(l)&&!!s.transposedVariableName;if(this._slices&&!o&&s.sliceId==null)return null;const c=o?0:n.maximumPyramidLevel-e+this._levelOffset,u=`${this.url}/tile/${c}/${r}/${i}`,f=this._slices?o?{variable:s.transposedVariableName}:{sliceId:s.sliceId||0}:null,{data:d}=await this.request(u,{query:f,responseType:"array-buffer",signal:s.signal});if(!d)return null;const h=o?l.tileSize:n.tileInfo.size,y=await this.decodePixelBlock(d,{width:h[0],height:h[1],planes:null,pixelType:null,isPoint:this.tileType==="Elevation",returnInterleaved:o}),p=n.blockBoundary[e];if(n.compression!=="jpg"||i>p.minCol&&i<p.maxCol&&r>p.minRow&&r<p.maxRow)return y;const{origin:m,blockWidth:g,blockHeight:x}=n,{x:I,y:C}=this.getPyramidPixelSize(e),P=Math.round((a.xmin-m.x)/I)%g,T=Math.round((a.xmax-m.x)/I)%g||g,v=Math.round((m.y-a.ymax)/C)%x,R=Math.round((m.y-a.ymin)/C)%x||x,S=i===p.minCol?P:0,_=r===p.minRow?v:0,F=i===p.maxCol?T:g,E=r===p.maxRow?R:x;return li(y,{x:S,y:_},{width:F-S,height:E-_}),y}getSliceIndex(e){if(!this._slices||M(e)||e.length===0)return null;const r=e;for(let i=0;i<this._slices.length;i++){const s=this._slices[i].multidimensionalDefinition;if(s.length===r.length&&!s.some(n=>{const a=r.find(l=>n.variableName===l.variableName&&l.dimensionName===n.dimensionName);return a?(Array.isArray(n.values[0])?`${n.values[0][0]}-${n.values[0][1]}`:n.values[0])!==(Array.isArray(a.values[0])?`${a.values[0][0]}-${a.values[0][1]}`:a.values[0]):!0}))return i}return null}async fetchVariableStatisticsHistograms(e,r){const i=this.request(this.url+"/statistics",{query:{variable:e,f:"json"},signal:r}).then(a=>{var l;return(l=a.data)==null?void 0:l.statistics}),s=this.request(this.url+"/histograms",{query:{variable:e,f:"json"},signal:r}).then(a=>{var l;return(l=a.data)==null?void 0:l.histograms}),n=await Promise.all([i,s]);return n[0]&&n[0].forEach(a=>{a.avg=a.mean,a.stddev=a.standardDeviation}),{statistics:n[0]||null,histograms:n[1]||null}}async computeBestPyramidLevelForLocation(e,r={}){if(!this._tilemapCache)return 0;let i=this.identifyPixelLocation(e,0,U(r.datumTransformation));if(i===null)return null;let s=0;const{maximumPyramidLevel:n}=this.rasterInfo.storageInfo;let a=n-s+this._levelOffset;const l=i.srcLocation;for(;a>=0;){try{if(await this._tilemapCache.fetchAvailability(a,i.row,i.col,r)==="available")break}catch{}if(a--,s++,i=this.identifyPixelLocation(l,s,U(r.datumTransformation)),i===null)return null}return a===-1||i==null?null:s}async _fetchRasterInfo(e){const r=this.sourceJSON;if(this.tileType==="Map"){const l=r.fullExtent||r.extent,o=Math.ceil((l.xmax-l.xmin)/r.pixelSizeX-.1),c=Math.ceil((l.ymax-l.ymin)/r.pixelSizeY-.1),u=J.fromJSON(r.spatialReference||l.spatialReference),f=new N({x:r.pixelSizeX,y:r.pixelSizeY,spatialReference:u});return new me({width:o,height:c,bandCount:3,extent:W.fromJSON(l),spatialReference:u,pixelSize:f,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}const{signal:i}=e,s=Nt(this.url,this.sourceJSON,{signal:i,query:this.ioConfig.customFetchParameters}),n=r.hasMultidimensions?this.request(`${this.url}/slices`,{query:{f:"json"},signal:i}).then(l=>l.data&&l.data.slices).catch(()=>null):null,a=await Promise.all([s,n]);return this._slices=a[1],a[0]}_fixScaleInServiceInfo(){const{sourceJSON:e}=this;e.minScale&&e.minScale<0&&(e.minScale=0),e.maxScale&&e.maxScale<0&&(e.maxScale=0)}_fixGCSShift(e){const{extent:r,spatialReference:i}=e;r.xmin>-1&&r.xmax>181&&(i!=null&&i.wkid)&&i.isGeographic&&(e.nativeExtent=e.extent,e.transform=new wi,e.extent=e.transform.forwardTransform(r))}_computeMinMaxLOD(e,r){const{pixelSize:i}=e,s=.5/e.width*i.x,{lods:n}=r,a=r.lodAt(Math.max.apply(null,n.map(h=>h.level))),l=r.lodAt(Math.min.apply(null,n.map(h=>h.level))),{tileType:o}=this;if(o==="Map")return this._levelOffset=n[0].level,[a,l];if(o==="Raster")return[n.find(h=>h.resolution===i.x)??a,l];const{minScale:c,maxScale:u}=this.sourceJSON;let f=a;u>0&&(f=n.find(h=>Math.abs(h.scale-u)<s),f||(f=n.filter(h=>h.scale>u).sort((h,y)=>h.scale>y.scale?1:-1)[0]??a));let d=l;return c>0&&(d=n.find(h=>Math.abs(h.scale-c)<s)??l,this._levelOffset=d.level-l.level),[f,d]}};w([b({type:String,json:{write:!0}})],ue.prototype,"datasetFormat",void 0),w([b()],ue.prototype,"tileType",void 0),ue=w([K("esri.layers.support.rasterDatasets.ImageServerRaster")],ue);const Fi=ue,X=new Map;X.set("Int8","s8"),X.set("UInt8","u8"),X.set("Int16","s16"),X.set("UInt16","u16"),X.set("Int32","s32"),X.set("UInt32","u32"),X.set("Float32","f32"),X.set("Float64","f32"),X.set("Double64","f32");const Q=new Map;Q.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),Q.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),Q.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),Q.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let re=class extends ie{constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async open(t){var p;await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const e=t?U(t.signal):null,r=await this.request(this.url,{responseType:"xml",signal:e}),{rasterInfo:i,files:s}=this._parseHeader(r.data);if(((p=this.ioConfig.skipExtensions)==null?void 0:p.indexOf("aux.xml"))===-1){const m=await this._fetchAuxiliaryData(t);m!=null&&(i.statistics=m.statistics??i.statistics,i.histograms=m.histograms,m.histograms&&M(i.statistics)&&(i.statistics=Pe(m.histograms)))}this._set("rasterInfo",i),this._files=s;const n=await this.request(s.index,{responseType:"array-buffer",signal:e});this._storageIndex=this._parseIndex(n.data);const{blockWidth:a,blockHeight:l}=this.rasterInfo.storageInfo,o=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:c,height:u}=this.rasterInfo,f=[],d=this._getBandSegmentCount();let h=0,y=-1;for(;h<this._storageIndex.length;){y++;const m=Math.ceil(c/a/o**y)-1,g=Math.ceil(u/l/o**y)-1;h+=(m+1)*(g+1)*d*4,f.push({maxRow:g,maxCol:m,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=f,y>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=y),this.updateTileInfo()}async fetchRawTile(t,e,r,i={}){const{blockWidth:s,blockHeight:n,blockBoundary:a}=this.rasterInfo.storageInfo,l=a[t];if(!l||l.maxRow<e||l.maxCol<r||l.minRow>e||l.minCol>r)return null;const{bandCount:o,pixelType:c}=this.rasterInfo,{ranges:u,actualTileWidth:f,actualTileHeight:d}=this._getTileLocation(t,e,r);if(!u||u.length===0)return null;if(u[0].from===0&&u[0].to===0){const S=new Uint8Array(s*n);return new ci({width:s,height:n,pixels:null,mask:S,validPixelCount:0})}const{bandIds:h}=this.ioConfig,y=this._getBandSegmentCount(),p=[];let m=0;for(m=0;m<y;m++)(!h||h.indexOf[m]>-1)&&p.push(this.request(this._files.data,{range:{from:u[m].from,to:u[m].to},responseType:"array-buffer",signal:i.signal}));const g=await Promise.all(p),x=g.map(S=>S.data.byteLength).reduce((S,_)=>S+_),I=new Uint8Array(x);let C=0;for(m=0;m<y;m++)I.set(new Uint8Array(g[m].data),C),C+=g[m].data.byteLength;const P=Q.get(this.rasterInfo.storageInfo.compression).decoderFormat,T=await this.decodePixelBlock(I.buffer,{width:s,height:n,format:P,planes:(h==null?void 0:h.length)||o,pixelType:c});if(k(this.rasterInfo.noDataValue)&&P!=="lerc"&&!T.mask){const S=this.rasterInfo.noDataValue[0];if(S!=null){const _=T.width*T.height,F=new Uint8Array(_);if(Math.abs(S)>1e24)for(m=0;m<_;m++)Math.abs((T.pixels[0][m]-S)/S)>1e-6&&(F[m]=1);else for(m=0;m<_;m++)T.pixels[0][m]!==S&&(F[m]=1);T.mask=F}}let v=0,R=0;if(f!==s||d!==n){let S=T.mask;if(S)for(m=0;m<n;m++)if(R=m*s,m<d)for(v=f;v<s;v++)S[R+v]=0;else for(v=0;v<s;v++)S[R+v]=0;else for(S=new Uint8Array(s*n),T.mask=S,m=0;m<d;m++)for(R=m*s,v=0;v<f;v++)S[R+v]=1}return T}_parseIndex(t){if(t.byteLength%16>0)throw"invalid array buffer must be multiples of 16";let e,r,i,s,n,a;if(Kt){for(r=new Uint8Array(t),s=new ArrayBuffer(t.byteLength),i=new Uint8Array(s),n=0;n<t.byteLength/4;n++)for(a=0;a<4;a++)i[4*n+a]=r[4*n+3-a];e=new Uint32Array(s)}else e=new Uint32Array(t);return e}_getBandSegmentCount(){return Q.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(t,e,r){const{blockWidth:i,blockHeight:s,pyramidScalingFactor:n}=this.rasterInfo.storageInfo,{width:a,height:l}=this.rasterInfo,o=this._getBandSegmentCount();let c,u,f,d=0,h=0;for(f=0;f<t;f++)h=n**f,c=Math.ceil(a/i/h),u=Math.ceil(l/s/h),d+=c*u;h=n**t,c=Math.ceil(a/i/h),u=Math.ceil(l/s/h),d+=e*c+r,d*=4*o;const y=this._storageIndex.subarray(d,d+4*o);let p=0,m=0;const g=[];for(let x=0;x<o;x++)p=y[4*x+0]*2**32+y[4*x+1],m=p+y[4*x+2]*2**32+y[4*x+3],g.push({from:p,to:m});return{ranges:g,actualTileWidth:r<c-1?i:Math.ceil(a/h)-i*(c-1),actualTileHeight:e<u-1?s:Math.ceil(l/h)-s*(u-1)}}_parseHeader(t){const e=A(t,"MRF_META/Raster");if(!e)throw new $("mrf:open","not a valid MRF format");const r=A(e,"Size"),i=parseInt(r.getAttribute("x"),10),s=parseInt(r.getAttribute("y"),10),n=parseInt(r.getAttribute("c"),10),a=(Y(e,"Compression")||"none").toLowerCase();if(!Q.has(a))throw new $("mrf:open","currently does not support compression "+a);const l=Y(e,"DataType")||"UInt8",o=X.get(l);if(o==null)throw new $("mrf:open","currently does not support pixel type "+l);const c=A(e,"PageSize"),u=parseInt(c.getAttribute("x"),10),f=parseInt(c.getAttribute("y"),10),d=A(e,"DataValues");let h,y;if(d&&(y=d.getAttribute("NoData"),y!=null&&(h=y.trim().split(" ").map(F=>parseFloat(F)))),A(t,"MRF_META/CachedSource"))throw new $("mrf:open","currently does not support MRF referencing other data files");const p=A(t,"MRF_META/GeoTags"),m=A(p,"BoundingBox");let g,x=!1;if(m!=null){const F=parseFloat(m.getAttribute("minx")),E=parseFloat(m.getAttribute("miny")),j=parseFloat(m.getAttribute("maxx")),H=parseFloat(m.getAttribute("maxy")),B=Y(p,"Projection")||"";let L=J.WGS84;if(B!=="LOCAL_CS[]")if(B.toLowerCase().startsWith("epsg:")){const G=Number(B.slice(5));isNaN(G)||G===0||(L=new J({wkid:G}))}else L=Se(B)??J.WGS84;else x=!0,L=new J({wkid:3857});g=new W(F,E,j,H),g.spatialReference=L}else x=!0,g=new W({xmin:-.5,ymin:.5-s,xmax:i-.5,ymax:.5,spatialReference:new J({wkid:3857})});const I=A(t,"MRF_META/Rsets"),C=parseInt(I&&I.getAttribute("scale")||"2",10),P=g.spatialReference,T=new de({origin:new N({x:g.xmin,y:g.ymax,spatialReference:P}),blockWidth:u,blockHeight:f,pyramidBlockWidth:u,pyramidBlockHeight:f,compression:a,pyramidScalingFactor:C}),v=new N({x:g.width/i,y:g.height/s,spatialReference:P}),R=new me({width:i,height:s,extent:g,isPseudoSpatialReference:x,spatialReference:P,bandCount:n,pixelType:o,pixelSize:v,noDataValue:h,storageInfo:T}),S=Y(t,"datafile"),_=Y(t,"IndexFile");return{rasterInfo:R,files:{mrf:this.url,index:_||this.url.replace(".mrf",".idx"),data:S||this.url.replace(".mrf",Q.get(a).blobExtension)}}}async _fetchAuxiliaryData(t){try{const{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:t==null?void 0:t.signal});return Me(e)}catch{return null}}};w([b()],re.prototype,"_files",void 0),w([b()],re.prototype,"_storageIndex",void 0),w([b({type:String,json:{write:!0}})],re.prototype,"datasetFormat",void 0),re=w([K("esri.layers.support.rasterIO.MRFRaster")],re);const Mi=re,Ce=(t,e)=>{var r;return(r=t.get(e))==null?void 0:r.values},oe=(t,e)=>{var r,i;return(i=(r=t.get(e))==null?void 0:r.values)==null?void 0:i[0]};let ee=class extends ie{constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this.datasetFormat="TIFF"}async open(t){await this.init();const e=t?U(t.signal):null,{data:r}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:e});if(!r)throw new $("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const{littleEndian:i,firstIFDPos:s,isBigTiff:n}=Qt(r),a=[];await this._readIFDs(a,r,i,s,0,n?8:4,e);const{imageInfo:l,rasterInfo:o}=this._parseIFDs(a);if(this._headerInfo={littleEndian:i,isBigTiff:n,ifds:a,...l},this._set("rasterInfo",o),!l.isSupported)throw new $("tiffraster:open","this tiff is not supported: "+l.message);if(!l.tileWidth)throw new $("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");const{skipExtensions:c=[]}=this.ioConfig;if(!c.includes("aux.xml")){const u=await this._fetchAuxiliaryMetaData(t);u!=null&&this._processPAMInfo(u,o)}c.includes("vat.dbf")||o.bandCount!==1||o.pixelType!=="u8"||(o.attributeTable=await this._fetchAuxiliaryTable(t),k(o.attributeTable)&&(o.keyProperties.DataType="thematic")),this.updateTileInfo()}async fetchRawTile(t,e,r,i={}){var P;if(!((P=this._headerInfo)!=null&&P.isSupported)||this.isBlockOutside(t,e,r))return null;const s=this._getTileLocation(t,e,r);if(!s)return null;const{ranges:n,actualTileWidth:a,actualTileHeight:l,ifd:o}=s,c=n.map(T=>this.request(this.url,{range:T,responseType:"array-buffer",signal:i.signal})),u=await Promise.all(c),f=u.map(T=>T.data.byteLength).reduce((T,v)=>T+v),d=u.length===1?u[0].data:new ArrayBuffer(f),h=[0],y=[0];if(u.length>1){const T=new Uint8Array(d);for(let v=0,R=0;v<u.length;v++){const S=u[v].data;T.set(new Uint8Array(S),R),h[v]=R,R+=S.byteLength,y[v]=S.byteLength}}const{blockWidth:p,blockHeight:m}=this.getBlockWidthHeight(t),g=await this.decodePixelBlock(d,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:o,offsets:h,sizes:y},width:p,height:m,planes:null,pixelType:null});let x,I,C;if(a!==p||l!==m){let T=g.mask;if(T)for(x=0;x<m;x++)if(C=x*p,x<l)for(I=a;I<p;I++)T[C+I]=0;else for(I=0;I<p;I++)T[C+I]=0;else for(T=new Uint8Array(p*m),g.mask=T,x=0;x<l;x++)for(C=x*p,I=0;I<a;I++)T[C+I]=1}return g}_parseIFDs(t){var E,j;const e=Zt(t),{width:r,height:i,tileWidth:s,tileHeight:n,planes:a,pixelType:l,compression:o,firstPyramidLevel:c,maximumPyramidLevel:u,pyramidBlockWidth:f,pyramidBlockHeight:d,tileBoundary:h,affine:y,metadata:p}=e,m=((E=e.extent.spatialReference)==null?void 0:E.wkt)||((j=e.extent.spatialReference)==null?void 0:j.wkid);let g=Se(m),x=!1;g==null&&(x=!0,g=new J({wkid:3857}));const I=new W({...e.extent,spatialReference:g}),C=new N(I?{x:I.xmin,y:I.ymax,spatialReference:g}:{x:0,y:0}),P=new de({blockWidth:s,blockHeight:n,pyramidBlockWidth:f,pyramidBlockHeight:d,compression:o,origin:C,firstPyramidLevel:c,maximumPyramidLevel:u,blockBoundary:h}),T=new N({x:(I.xmax-I.xmin)/r,y:(I.ymax-I.ymin)/i,spatialReference:g}),v=p?{BandProperties:p.bandProperties,DataType:p.dataType}:{};let R=null;const S=oe(t[0],"PHOTOMETRICINTERPRETATION"),_=Ce(t[0],"COLORMAP");if(S===3&&(_==null?void 0:_.length)>3&&_.length%3==0){R=[];const H=_.length/3;for(let B=0;B<H;B++)R.push([B,_[B]>>>8,_[B+H]>>>8,_[B+2*H]>>>8])}const F=new me({width:r,height:i,bandCount:a,pixelType:l,pixelSize:T,storageInfo:P,spatialReference:g,isPseudoSpatialReference:x,keyProperties:v,extent:I,colormap:R,statistics:p?p.statistics:null});return y!=null&&y.length&&(F.nativeExtent=new W({xmin:-.5,ymin:.5-i,xmax:r-.5,ymax:.5,spatialReference:g}),F.transform=new Fe({polynomialOrder:1,forwardCoefficients:[y[2]+y[0]/2,y[5]-y[3]/2,y[0],y[3],-y[1],-y[4]]}),F.extent=F.transform.forwardTransform(F.nativeExtent),F.pixelSize=new N({x:(I.xmax-I.xmin)/r,y:(I.ymax-I.ymin)/i,spatialReference:g}),P.origin.x=-.5,P.origin.y=.5),{imageInfo:e,rasterInfo:F}}_processPAMInfo(t,e){if(e.statistics=t.statistics??e.statistics,e.histograms=t.histograms,t.histograms&&M(e.statistics)&&(e.statistics=Pe(t.histograms)),t.transform&&M(e.transform)){e.transform=t.transform,e.nativeExtent=e.extent;const r=e.transform.forwardTransform(e.nativeExtent);e.pixelSize=new N({x:(r.xmax-r.xmin)/e.width,y:(r.ymax-r.ymin)/e.height,spatialReference:e.spatialReference}),e.extent=r}e.spatialReference||(e.spatialReference=t.spatialReference)}async _readIFDs(t,e,r,i,s,n=4,a){if(!i)return null;(i>=e.byteLength||i<0)&&(e=(await this.request(this.url,{range:{from:i+s,to:i+s+this._bufferSize},responseType:"array-buffer",signal:a})).data,s=i+s,i=0);const l=await this._readIFD(e,r,i,s,ye.TIFF_TAGS,n,a);if(t.push(l.ifd),!l.nextIFD)return null;await this._readIFDs(t,e,r,l.nextIFD-s,s,n,a)}async _readIFD(t,e,r,i,s=ye.TIFF_TAGS,n=4,a){var o,c;if(!t)return null;const l=ei(t,e,r,i,s,n);if(l.success){const u=[];if((o=l.ifd)==null||o.forEach(f=>{f.values||u.push(f)}),u.length>0){const f=u.map(h=>h.offlineOffsetSize).filter(k),d=Math.min.apply(null,f.map(h=>h[0]));if(Math.min.apply(null,f.map(h=>h[0]+h[1]))-d<=this._bufferSize){const{data:h}=await this.request(this.url,{range:{from:d,to:d+this._bufferSize},responseType:"array-buffer",signal:a});t=h,i=d,u.forEach(y=>ti(t,e,y,i))}}if((c=l.ifd)!=null&&c.has("GEOKEYDIRECTORY")){const f=l.ifd.get("GEOKEYDIRECTORY"),d=f==null?void 0:f.values;if(d&&d.length>4){const h=d[0]+"."+d[1]+"."+d[2],y=await this._readIFD(t,e,f.valueOffset+6-i,i,ye.GEO_KEYS,2,a);f.data=y.ifd,f.data&&f.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[h]})}}return l}if(l.requiredBufferSize&&l.requiredBufferSize!==t.byteLength)return(t=(await this.request(this.url,{range:{from:i,to:i+l.requiredBufferSize+4},responseType:"array-buffer",signal:a})).data).byteLength<l.requiredBufferSize?null:this._readIFD(t,e,0,i,ye.TIFF_TAGS,4,a)}_getTileLocation(t,e,r){var v;const{firstPyramidLevel:i,blockBoundary:s}=this.rasterInfo.storageInfo,n=t===0?0:t-(i-1),a=(v=this._headerInfo)==null?void 0:v.ifds[n];if(!a)return null;const l=ii(a,this._headerInfo),o=Ce(a,"TILEOFFSETS");if(o===void 0)return null;const c=Ce(a,"TILEBYTECOUNTS"),{minRow:u,minCol:f,maxRow:d,maxCol:h}=s[n];if(e>d||r>h||e<u||r<f)return null;const y=oe(a,"IMAGEWIDTH"),p=oe(a,"IMAGELENGTH"),m=oe(a,"TILEWIDTH"),g=oe(a,"TILELENGTH"),x=l?this.rasterInfo.bandCount:1,I=x*e*(h+1)+r,C=[{from:o[I],to:o[I+x-1]+c[I+x-1]-1}];if(l){let R=!0;for(let S=0;S<x;S++)if(o[I+S]+c[I+S]!==o[I+S+1]){R=!1;break}if(!R)for(let S=0;S<x;S++)C[S]={from:o[I+S],to:o[I+S]+c[I+S]-1}}const P=o[I],T=c[I];return P==null||T==null?null:{ranges:C,ifd:a,actualTileWidth:r===h&&y%m||m,actualTileHeight:e===d&&p%g||g}}async _fetchAuxiliaryMetaData(t){try{const{data:e}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:t==null?void 0:t.signal});return Me(e)}catch{return null}}async _fetchAuxiliaryTable(t){try{const{data:e}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:t==null?void 0:t.signal}),r=st.parse(e);return r!=null&&r.recordSet?Ye.fromJSON(r.recordSet):null}catch{return null}}};w([b()],ee.prototype,"_files",void 0),w([b()],ee.prototype,"_headerInfo",void 0),w([b()],ee.prototype,"_bufferSize",void 0),w([b({type:String,json:{write:!0}})],ee.prototype,"datasetFormat",void 0),ee=w([K("esri.layers.support.rasterDatasets.TIFFRaster")],ee);const $i=ee,z=new Map;z.set("CRF",{desc:"Cloud Raster Format",constructor:Ri}),z.set("MRF",{desc:"Meta Raster Format",constructor:Mi}),z.set("TIFF",{desc:"GeoTIFF",constructor:$i}),z.set("RasterTileServer",{desc:"Raster Tile Server",constructor:Fi}),z.set("JPG",{desc:"JPG Raster Format",constructor:we}),z.set("PNG",{desc:"PNG Raster Format",constructor:we}),z.set("GIF",{desc:"GIF Raster Format",constructor:we}),z.set("BMP",{desc:"BMP Raster Format",constructor:we});class Oi{static get supportedFormats(){const e=new Set;return z.forEach((r,i)=>e.add(i)),e}static async open(e){const{url:r,ioConfig:i,sourceJSON:s}=e;let n=e.datasetFormat;n==null&&r.lastIndexOf(".")&&(n=r.slice(r.lastIndexOf(".")+1).toUpperCase()),n==="OVR"||n==="TIF"?n="TIFF":n!=="JPG"&&n!=="JPEG"&&n!=="JFIF"||(n="JPG"),r.toLowerCase().includes("/imageserver")&&!r.toLowerCase().includes("/wcsserver")&&(n="RasterTileServer");const a={url:r,sourceJSON:s,datasetFormat:n,ioConfig:i??{bandIds:null,sampling:null}};let l,o;if(n&&this.supportedFormats.has(n)){if(n==="CRF"&&!(i!=null&&i.enableCRF))throw new $("rasterfactory:open",`cannot open raster: ${r}`);return l=z.get(n).constructor,o=new l(a),await o.open({signal:e.signal}),o}if(n)throw new $("rasterfactory:open","not a supported format "+n);const c=Array.from(z.keys());let u=0;const f=()=>(n=c[u++],n&&(n!=="CRF"||i!=null&&i.enableCRF)?(l=z.get(n).constructor,o=new l(a),o.open({signal:e.signal}).then(()=>o).catch(()=>f())):null);return f()}static register(e,r,i){z.has(e.toUpperCase())||z.set(e.toUpperCase(),{desc:r,constructor:i})}}let O=class extends pt(yt(gt(xt(It(vi(wt(bt(St(Mt))))))))){constructor(...t){super(...t),this.bandIds=null,this.interpolation=null,this.legendEnabled=!0,this.isReference=null,this.listMode="show",this.sourceJSON=null,this.version=null,this.title=null,this.type="imagery-tile",this.operationalLayerType="ArcGISTiledImageServiceLayer",this.popupEnabled=!0,this.popupTemplate=null,this.fields=null}normalizeCtorArgs(t,e){return typeof t=="string"?{url:t,...e}:t}load(t){const e=k(t)?t.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Image Service"]},t).catch(vt).then(()=>this._openRaster(e))),Promise.resolve(this)}get defaultPopupTemplate(){return this.createPopupTemplate()}get rasterFields(){var l;let t=[new he({name:"Raster.ServicePixelValue",alias:"Pixel Value",domain:null,editable:!1,length:50,type:"string"})];const{rasterInfo:e}=this,{attributeTable:r}=e,i=k(r)?r.fields:null,s="Raster.";if(i){const o=i.filter(c=>c.type!=="oid"&&c.name.toLowerCase()!=="value").map(c=>{const u=c.clone();return u.name=s+c.name,u});t=t.concat(o)}const{dataType:n,multidimensionalInfo:a}=e;if((n==="vector-magdir"||n==="vector-uv")&&k(a)){const o=(l=a.variables[0].unit)==null?void 0:l.trim(),c="Magnitude"+(o?` (${o})`:"");t.push(new he({name:"Raster.Magnitude",alias:c,domain:null,editable:!1,type:"double"})),t.push(new he({name:"Raster.Direction",alias:"Direction (°)",domain:null,editable:!1,type:"double"}))}return t}set renderer(t){this._set("renderer",t),this.updateRenderer()}readRenderer(t,e,r){const i=e&&e.layerDefinition&&e.layerDefinition.drawingInfo&&e.layerDefinition.drawingInfo.renderer,s=Jt(i,r)||void 0;if(s!=null)return s}createPopupTemplate(t){return Tt({fields:this.rasterFields,title:this.title},t)}write(t,e){const{raster:r}=this;if(this.loaded?r.datasetFormat==="RasterTileServer"&&(r.tileType==="Raster"||r.tileType==="Map"):this.url&&/\/ImageServer(\/|\/?$)/i.test(this.url))return super.write(t,e);if(e&&e.messages){const i=`${e.origin}/${e.layerContainerType||"operational-layers"}`;e.messages.push(new $("layer:unsupported",`Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${i}'`,{layer:this}))}return null}async _openRaster(t){if(this.raster)this.raster.rasterInfo||await this.raster.open(),this.url=this.raster.url;else{const r=await Oi.open({url:this.url,sourceJSON:this.sourceJSON,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:t});if(this.rasterFunction){const i=tt(this.rasterFunction.toJSON(),{raster:r}),s=new it({rasterFunction:i});await s.open(),this.raster=s}else this.raster=r}const{rasterInfo:e}=this.raster;if(!e)throw new $("imagery-tile-layer:load","cannot load resources on "+this.url);if(this.sourceJSON=this.sourceJSON||this.raster.sourceJSON,this.sourceJSON!=null){const r=this.raster.tileType==="Map"&&this.sourceJSON.minLOD!=null&&this.sourceJSON.maxLOD!=null?this.sourceJSON:{...this.sourceJSON,minScale:0,maxScale:0};this.read(r,{origin:"service"})}this.title==null&&(this.title=this.raster.datasetName),this.raster.tileType==="Map"&&(this.popupEnabled=!1),this._configDefaultSettings(),this.addHandles(Rt(()=>this.customParameters,r=>{this.raster.ioConfig.customFetchParameters=r}))}};w([b({type:[_t],json:{write:{overridePolicy(){var t;return{enabled:!this.loaded||this.raster.tileType==="Raster"||((t=this.bandIds)==null?void 0:t.join(","))!=="0,1,2"}}}}})],O.prototype,"bandIds",void 0),w([b({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),kt(Ht)],O.prototype,"interpolation",void 0),w([b({json:{write:!0}})],O.prototype,"multidimensionalDefinition",void 0),w([b(Ct)],O.prototype,"legendEnabled",void 0),w([b({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],O.prototype,"isReference",void 0),w([b({type:["show","hide"]})],O.prototype,"listMode",void 0),w([b({json:{read:!0,write:!0}})],O.prototype,"blendMode",void 0),w([b()],O.prototype,"sourceJSON",void 0),w([b({readOnly:!0,json:{origins:{service:{read:{source:"currentVersion"}}}}})],O.prototype,"version",void 0),w([b()],O.prototype,"title",void 0),w([b({readOnly:!0,json:{read:!1}})],O.prototype,"type",void 0),w([b({type:["ArcGISTiledImageServiceLayer"]})],O.prototype,"operationalLayerType",void 0),w([b({type:Boolean,value:!0,json:{read:{source:"disablePopup",reader:(t,e)=>!e.disablePopup},write:{target:"disablePopup",overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"}},writer(t,e,r){e[r]=!t}}}})],O.prototype,"popupEnabled",void 0),w([b({type:Pt,json:{read:{source:"popupInfo"},write:{target:"popupInfo",overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"}}}}})],O.prototype,"popupTemplate",void 0),w([b({readOnly:!0})],O.prototype,"defaultPopupTemplate",null),w([b({readOnly:!0,type:[he]})],O.prototype,"fields",void 0),w([b({readOnly:!0,type:[he]})],O.prototype,"rasterFields",null),w([b({types:Qe,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var e;const t=((e=this.renderer)==null?void 0:e.type)==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!t}}},origins:{"web-scene":{types:Lt,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:t=>({enabled:t&&t.type!=="vector-field"&&t.type!=="flow"})}}}}})],O.prototype,"renderer",null),w([Ft("renderer")],O.prototype,"readRenderer",null),O=w([K("esri.layers.ImageryTileLayer")],O);const qi=O;export{qi as default};
