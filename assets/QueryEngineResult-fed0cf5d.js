import{e1 as Y,s as S,gp as P,gq as ce,Q as ae,cA as de,cB as H,M as U,gr as he,gs as X,gt as k,gu as W,gv as fe,gw as ge,gx as me,gy as pe,gz as ye,gA as xe,gB as Fe,gC as J,q as Ie,gD as _e,gE as K,b5 as Ve,gF as Te,gG as ve,em as De}from"./vendor-8855e047.js";import{WhereClause as Ae}from"./WhereClause-b5dbe378.js";import{g as ee}from"./projectionSupport-e3191e9a.js";import{E as $,v as O,b as te}from"./utils-22c67127.js";let be=class{constructor(t,e){this._cache=new Y(t),this._invalidCache=new Y(e)}get(t,e){const s=`${e.uid}:${t}`,a=this._cache.get(s);if(a)return a;if(this._invalidCache.get(s)!==void 0)return null;try{const i=Ae.create(t,e);return this._cache.put(s,i),i}catch{return this._invalidCache.put(s,null),null}}};const j=new be(50,500),w="feature-store:unsupported-query",ne=" as ",ze=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function Pe(u,t){if(!t)return!0;const e=j.get(t,u);if(!e)throw new S(w,"invalid SQL expression",{where:t});if(!e.isStandardized)throw new S(w,"where clause is not standard",{where:t});return Q(u,e.fieldNames,"where clause contains missing fields"),!0}function $e(u,t,e){if(!t)return!0;const s=j.get(t,u);if(!s)throw new S(w,"invalid SQL expression",{having:t});if(!s.isAggregate)throw new S(w,"having does not contain a valid aggregate function",{having:t});const a=s.fieldNames;if(Q(u,a,"having contains missing fields"),!s.getExpressions().every(i=>{const{aggregateType:n,field:r}=i,o=u.has(r)&&u.get(r).name;return e.some(c=>{const{onStatisticField:l,statisticType:d}=c;return(u.has(l)&&u.get(l).name)===o&&d.toLowerCase().trim()===n})}))throw new S(w,"expressions in having should also exist in outStatistics",{having:t});return!0}function q(u,t){return u?j.get(u,t):null}function Q(u,t,e,s=!0){const a=[];for(const i of t)if(i!=="*"&&!u.has(i))if(s){const n=re(i);try{const r=q(n,u);if(!r)throw new S(w,"invalid SQL expression",{where:n});if(!r.isStandardized)throw new S(w,"expression is not standard",{clause:r});Q(u,r.fieldNames,"expression contains missing fields")}catch(r){const o=r&&r.details;if(o&&(o.clause||o.where))throw r;o&&o.missingFields?a.push(...o.missingFields):a.push(i)}}else a.push(i);if(a.length)throw new S(w,e,{missingFields:a})}function re(u){return u.split(ne)[0]}function Se(u){return u.split(ne)[1]}function Oe(u,t){const e=t.get(u);return!!e&&!ze.has(e.type)}class M{constructor(t,e,s){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=t.returnDistinctValues??!1,this.fieldsIndex=s,this.featureAdapter=e;const a=t.outFields;if(a&&!a.includes("*")){this.outFields=a;let i=0;for(const n of a){const r=re(n),o=this.fieldsIndex.get(r),c=o?null:q(r,s),l=o?o.name:Se(n)||"FIELD_EXP_"+i++;this._fieldDataCache.set(n,{alias:l,clause:c})}}}countDistinctValues(t){return this.returnDistinctValues?(t.forEach(e=>this.getAttributes(e)),this._returnDistinctMap.size):t.length}getAttributes(t){const e=this._processAttributesForOutFields(t);return this._processAttributesForDistinctValues(e)}getFieldValue(t,e,s){const a=s?s.name:e;let i=null;return this._fieldDataCache.has(a)?i=this._fieldDataCache.get(a).clause:s||(i=q(e,this.fieldsIndex),this._fieldDataCache.set(a,{alias:a,clause:i})),s?this.featureAdapter.getAttribute(t,a):i.calculateValue(t,this.featureAdapter)}getDataValue(t,e){const s=e.normalizationType,a=e.normalizationTotal;let i=this.getFieldValue(t,e.field,this.fieldsIndex.get(e.field));if(e.field2&&(i=`${P(i)}${e.fieldDelimiter}${P(this.getFieldValue(t,e.field2,this.fieldsIndex.get(e.field2)))}`,e.field3&&(i=`${i}${e.fieldDelimiter}${P(this.getFieldValue(t,e.field3,this.fieldsIndex.get(e.field3)))}`)),s&&Number.isFinite(i)){const n=s==="field"&&e.normalizationField?this.getFieldValue(t,e.normalizationField,this.fieldsIndex.get(e.normalizationField)):null;i=ce(i,s,n,a)}return i}getExpressionValue(t,e,s,a){const i={attributes:this.featureAdapter.getAttributes(t),layer:{fields:this.fieldsIndex.fields}},n=a.createExecContext(i,s);return a.executeFunction(e,n)}getExpressionValues(t,e,s,a){const i={fields:this.fieldsIndex.fields};return t.map(n=>{const r={attributes:this.featureAdapter.getAttributes(n),layer:i},o=a.createExecContext(r,s);return a.executeFunction(e,o)})}validateItem(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:q(e,this.fieldsIndex)}),this._fieldDataCache.get(e).clause.testFeature(t,this.featureAdapter)}validateItems(t,e){return this._fieldDataCache.has(e)||this._fieldDataCache.set(e,{alias:e,clause:q(e,this.fieldsIndex)}),this._fieldDataCache.get(e).clause.testSet(t,this.featureAdapter)}_processAttributesForOutFields(t){const e=this.outFields;if(!e||!e.length)return this.featureAdapter.getAttributes(t);const s={};for(const a of e){const{alias:i,clause:n}=this._fieldDataCache.get(a);s[i]=n?n.calculateValue(t,this.featureAdapter):this.featureAdapter.getAttribute(t,i)}return s}_processAttributesForDistinctValues(t){if(ae(t)||!this.returnDistinctValues)return t;const e=this.outFields,s=[];if(e)for(const n of e){const{alias:r}=this._fieldDataCache.get(n);s.push(t[r])}else for(const n in t)s.push(t[n]);const a=`${(e||["*"]).join(",")}=${s.join(",")}`;let i=this._returnDistinctMap.get(a)||0;return this._returnDistinctMap.set(a,++i),i>1?null:t}}function we(u,t,e){return{objectId:u,target:t,distance:e,type:"vertex"}}function Ee(u,t,e,s,a,i=!1){return{objectId:u,target:t,distance:e,type:"edge",start:s,end:a,draped:i}}class je{constructor(t,e,s){this.items=t,this.query=e,this.geometryType=s.geometryType,this.hasM=s.hasM,this.hasZ=s.hasZ,this.fieldsIndex=s.fieldsIndex,this.objectIdField=s.objectIdField,this.spatialReference=s.spatialReference,this.featureAdapter=s.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const t=new M(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:e,having:s,outStatistics:a}=this.query;if(!(e==null?void 0:e.length))return 1;const n=new Map,r=new Map,o=new Set;for(const c of a){const{statisticType:l}=c,d=l!=="exceedslimit"?c.onStatisticField:void 0;if(!r.has(d)){const h=[];for(const m of e){const x=this._getAttributeValues(t,m,n);h.push(x)}r.set(d,this._calculateUniqueValues(h,t.returnDistinctValues))}const f=r.get(d);for(const h in f){const{data:m,items:x}=f[h],V=m.join(",");s&&!t.validateItems(x,s)||o.add(V)}}return o.size}async createQueryResponse(){let t;return this.query.outStatistics?t=this.query.outStatistics.some(e=>e.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(this.query):await this._createStatisticsQueryResponse(this.query):t=this._createFeatureQueryResponse(this.query),this.query.returnQueryGeometry&&(de(this.query.outSR)&&!H(this.query.geometry.spatialReference,this.query.outSR)?t.queryGeometry=$({spatialReference:this.query.outSR,...ee(this.query.geometry,this.query.geometry.spatialReference,this.query.outSR)}):t.queryGeometry=$({spatialReference:this.query.outSR,...this.query.geometry})),t}createSnappingResponse(t,e){const s=this.featureAdapter,a=se(this.hasZ,this.hasM),{point:i}=t,n=typeof t.distance=="number"?t.distance:t.distance.x,r=typeof t.distance=="number"?t.distance:t.distance.y,o={candidates:[]},c=this.geometryType==="esriGeometryPolygon",l=i.z!=null,d=i.m!=null,f=this._getPointCreator(i,l,d,this.spatialReference,e),h=new ie(null,0),m=new ie(null,0),x={x:0,y:0,z:0};for(const V of this.items){const y=s.getGeometry(V);if(ae(y))continue;const{coords:I,lengths:_}=y;if(h.coords=I,m.coords=I,t.types&G.EDGE){let F=0;for(let p=0;p<_.length;p++){const g=_[p];for(let T=0;T<g;T++,F+=a){const D=h;if(D.coordsIndex=F,T!==g-1){const b=m;b.coordsIndex=F+a;const v=x;Ce(x,i,D,b);const A=(i.x-v.x)/n,C=(i.y-v.y)/r,E=A*A+C*C;E<=1&&o.candidates.push(Ee(s.getObjectId(V),f(v),Math.sqrt(E),f(D),f(b)))}}}}if(t.types&G.VERTEX){const F=c?I.length-a:I.length;for(let p=0;p<F;p+=a){const g=h;g.coordsIndex=p;const T=(i.x-g.x)/n,D=(i.y-g.y)/r,b=T*T+D*D;b<=1&&o.candidates.push(we(s.getObjectId(V),f(g),Math.sqrt(b)))}}}return o.candidates.sort((V,y)=>V.distance-y.distance),o}_getPointCreator(t,e,s,a,i){const n=U(i)&&!H(a,i)?l=>ee(l,a,i):l=>l,{hasZ:r}=this,o=0,c=t.m;return e&&s?r?({x:l,y:d,z:f})=>n({x:l,y:d,z:f,m:c}):({x:l,y:d})=>n({x:l,y:d,z:o,m:c}):e?r?({x:l,y:d,z:f})=>n({x:l,y:d,z:f}):({x:l,y:d})=>n({x:l,y:d,z:o}):s?({x:l,y:d})=>n({x:l,y:d,m:c}):({x:l,y:d})=>n({x:l,y:d})}async createSummaryStatisticsResponse(t){const{field:e,valueExpression:s,normalizationField:a,normalizationType:i,normalizationTotal:n,minValue:r,maxValue:o,scale:c}=t,l=this.fieldsIndex.isDateField(e),d=await this._getDataValues({field:e,valueExpression:s,normalizationField:a,normalizationType:i,normalizationTotal:n,scale:c}),f=he({normalizationType:i,normalizationField:a,minValue:r,maxValue:o}),h=this.fieldsIndex.get(e),m={value:.5,fieldType:h==null?void 0:h.type},x=X(h)?k({values:d,supportsNullCount:f,percentileParams:m}):W({values:d,minValue:r,maxValue:o,useSampleStdDev:!i,supportsNullCount:f,percentileParams:m});return fe(x,l)}async createUniqueValuesResponse(t){const{field:e,valueExpression:s,domains:a,returnAllCodedValues:i,scale:n}=t,r=await this._getDataValues({field:e,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,valueExpression:s,scale:n}),o=ge(r);return me(o,a,i,t.fieldDelimiter)}async createClassBreaksResponse(t){const{field:e,valueExpression:s,normalizationField:a,normalizationType:i,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:c,maxValue:l,numClasses:d,scale:f}=t,h=await this._getDataValues({field:e,valueExpression:s,normalizationField:a,normalizationType:i,normalizationTotal:n,scale:f}),m=pe(h,{field:e,normalizationField:a,normalizationType:i,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:c,maxValue:l,numClasses:d});return ye(m,r)}async createHistogramResponse(t){const{field:e,valueExpression:s,normalizationField:a,normalizationType:i,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:c,maxValue:l,numBins:d,scale:f}=t,h=await this._getDataValues({field:e,valueExpression:s,normalizationField:a,normalizationType:i,normalizationTotal:n,scale:f});return xe(h,{field:e,normalizationField:a,normalizationType:i,normalizationTotal:n,classificationMethod:r,standardDeviationInterval:o,minValue:c,maxValue:l,numBins:d})}_sortFeatures(t,e,s){if(t.length>1&&e&&e.length)for(const a of e.reverse()){const i=a.split(" "),n=i[0],r=this.fieldsIndex.get(n),o=i[1]&&i[1].toLowerCase()==="desc",c=Fe(r==null?void 0:r.type,o);t.sort((l,d)=>{const f=s(l,n,r),h=s(d,n,r);return c(f,h)})}}_createFeatureQueryResponse(t){const e=this.items,{geometryType:s,hasM:a,hasZ:i,objectIdField:n,spatialReference:r}=this,{outFields:o,outSR:c,quantizationParameters:l,resultRecordCount:d,resultOffset:f,returnZ:h,returnM:m}=t,x=d!=null&&e.length>(f||0)+d,V=o&&(o.includes("*")?[...this.fieldsIndex.fields]:o.map(y=>this.fieldsIndex.get(y)));return{exceededTransferLimit:x,features:this._createFeatures(t,e),fields:V,geometryType:s,hasM:a&&m,hasZ:i&&h,objectIdFieldName:n,spatialReference:$(c||r),transform:l&&J(l)||null}}_createFeatures(t,e){const s=new M(t,this.featureAdapter,this.fieldsIndex),{hasM:a,hasZ:i}=this,{orderByFields:n,quantizationParameters:r,returnGeometry:o,returnCentroid:c,maxAllowableOffset:l,resultOffset:d,resultRecordCount:f,returnZ:h=!1,returnM:m=!1}=t,x=i&&h,V=a&&m;let y=[],I=0;const _=[...e];if(this._sortFeatures(_,n,(p,g,T)=>s.getFieldValue(p,g,T)),o||c){const p=J(r);if(o&&!c)for(const g of _)y[I++]={attributes:s.getAttributes(g),geometry:O(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),l,p,x,V)};else if(!o&&c)for(const g of _)y[I++]={attributes:s.getAttributes(g),centroid:te(this,this.featureAdapter.getCentroid(g,this),p)};else for(const g of _)y[I++]={attributes:s.getAttributes(g),centroid:te(this,this.featureAdapter.getCentroid(g,this),p),geometry:O(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),l,p,x,V)}}else for(const p of _){const g=s.getAttributes(p);g&&(y[I++]={attributes:g})}const F=d||0;if(f!=null){const p=F+f;y=y.slice(F,Math.min(y.length,p))}return y}_createExceedsLimitQueryResponse(t){let e=!1,s=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY;for(const n of t.outStatistics)if(n.statisticType==="exceedslimit"){s=n.maxPointCount!=null?n.maxPointCount:Number.POSITIVE_INFINITY,a=n.maxRecordCount!=null?n.maxRecordCount:Number.POSITIVE_INFINITY,i=n.maxVertexCount!=null?n.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")e=this.items.length>s;else if(this.items.length>a)e=!0;else{const n=se(this.hasZ,this.hasM),r=this.featureAdapter;e=this.items.reduce((o,c)=>{const l=r.getGeometry(c);return o+(U(l)&&l.coords.length||0)},0)/n>i}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(t){const e={attributes:{}},s=[],a=new Map,i=new Map,n=new Map,r=new Map,o=new M(t,this.featureAdapter,this.fieldsIndex),c=t.outStatistics,{groupByFieldsForStatistics:l,having:d,orderByFields:f}=t,h=l&&l.length,m=!!h,x=m&&l[0],V=m&&!this.fieldsIndex.get(x);for(const I of c){const{outStatisticFieldName:_,statisticType:F}=I,p=I,g=F!=="exceedslimit"?I.onStatisticField:void 0,T=F==="percentile_disc"||F==="percentile_cont",D=F==="EnvelopeAggregate"||F==="CentroidAggregate"||F==="ConvexHullAggregate",b=m&&h===1&&(g===x||V)&&F==="count";if(m){if(!n.has(g)){const A=[];for(const C of l){const E=this._getAttributeValues(o,C,a);A.push(E)}n.set(g,this._calculateUniqueValues(A,!D&&o.returnDistinctValues))}const v=n.get(g);for(const A in v){const{count:C,data:E,items:Z,itemPositions:oe}=v[A],B=E.join(",");if(!d||o.validateItems(Z,d)){const R=r.get(B)||{attributes:{}};if(D){R.aggregateGeometries||(R.aggregateGeometries={});const{aggregateGeometries:z,outStatisticFieldName:N}=await this._getAggregateGeometry(p,Z);R.aggregateGeometries[N]=z}else{let z=null;if(b)z=C;else{const N=this._getAttributeValues(o,g,a),L=oe.map(ue=>N[ue]);z=T&&"statisticParameters"in p?this._getPercentileValue(p,L):this._getStatisticValue(p,L,null,o.returnDistinctValues)}R.attributes[_]=z}let le=0;l.forEach((z,N)=>R.attributes[this.fieldsIndex.get(z)?z:"EXPR_"+ ++le]=E[N]),r.set(B,R)}}}else if(D){e.aggregateGeometries||(e.aggregateGeometries={});const{aggregateGeometries:v,outStatisticFieldName:A}=await this._getAggregateGeometry(p,this.items);e.aggregateGeometries[A]=v}else{const v=this._getAttributeValues(o,g,a);e.attributes[_]=T&&"statisticParameters"in p?this._getPercentileValue(p,v):this._getStatisticValue(p,v,i,o.returnDistinctValues)}s.push({name:_,alias:_,type:"esriFieldTypeDouble"})}const y=m?Array.from(r.values()):[e];return this._sortFeatures(y,f,(I,_)=>I.attributes[_]),{fields:s,features:y}}async _getAggregateGeometry(t,e){const s=await Ie(()=>import("./geometryEngineJSON-a45b7108.js"),["assets/geometryEngineJSON-a45b7108.js","assets/geometryEngineBase-3dd302e0.js","assets/geometryEngineJSON-45c195fe.js","assets/json-48e3ea08.js"]),{statisticType:a,outStatisticFieldName:i}=t,{featureAdapter:n,spatialReference:r,geometryType:o,hasZ:c,hasM:l}=this,d=e.map(m=>O(o,c,l,n.getGeometry(m))),f=s.convexHull(r,d,!0)[0],h={aggregateGeometries:null,outStatisticFieldName:null};if(a==="EnvelopeAggregate"){const m=f?_e(f):K(s.union(r,d));h.aggregateGeometries={...m,spatialReference:r},h.outStatisticFieldName=i||"extent"}else if(a==="CentroidAggregate"){const m=f?Ve(f):Te(K(s.union(r,d)));h.aggregateGeometries={x:m[0],y:m[1],spatialReference:r},h.outStatisticFieldName=i||"centroid"}else a==="ConvexHullAggregate"&&(h.aggregateGeometries=f,h.outStatisticFieldName=i||"convexHull");return h}_getStatisticValue(t,e,s,a){const{onStatisticField:i,statisticType:n}=t;let r=null;return r=s!=null&&s.has(i)?s.get(i):X(this.fieldsIndex.get(i))?k({values:e,returnDistinct:a}):W({values:e,minValue:null,maxValue:null,useSampleStdDev:!0}),s&&s.set(i,r),r[n==="var"?"variance":n]}_getPercentileValue(t,e){const{onStatisticField:s,statisticParameters:a,statisticType:i}=t,{value:n,orderBy:r}=a,o=this.fieldsIndex.get(s);return ve(e,{value:n,orderBy:r,fieldType:o==null?void 0:o.type,isDiscrete:i==="percentile_disc"})}_getAttributeValues(t,e,s){if(s.has(e))return s.get(e);const a=this.fieldsIndex.get(e),i=this.items.map(n=>t.getFieldValue(n,e,a));return s.set(e,i),i}_getAttributeDataValues(t,e){return this.items.map(s=>t.getDataValue(s,{field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal}))}async _getAttributeExpressionValues(t,e,s){const{arcadeUtils:a}=await De(),i=a.createFunction(e),n=s&&a.getViewInfo(s);return t.getExpressionValues(this.items,i,n,a)}_calculateUniqueValues(t,e){const s={},a=this.items,i=a.length;for(let n=0;n<i;n++){const r=a[n],o=[];for(const l of t)o.push(l[n]);const c=o.join(",");e?s[c]==null&&(s[c]={count:1,data:o,items:[r],itemPositions:[n]}):s[c]==null?s[c]={count:1,data:o,items:[r],itemPositions:[n]}:(s[c].count++,s[c].items.push(r),s[c].itemPositions.push(n))}return s}async _getDataValues(t){const e=new M(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:s,field:a,normalizationField:i,normalizationType:n,normalizationTotal:r,scale:o}=t,c=s?{viewingMode:"map",scale:o,spatialReference:this.query.outSR||this.spatialReference}:null;return s?this._getAttributeExpressionValues(e,s,c):this._getAttributeDataValues(e,{field:a,field2:t.field2,field3:t.field3,fieldDelimiter:t.fieldDelimiter,normalizationField:i,normalizationType:n,normalizationTotal:r})}}function Ce(u,t,e,s){const a=s.x-e.x,i=s.y-e.y,n=a*a+i*i,r=(t.x-e.x)*a+(t.y-e.y)*i,o=Math.min(1,Math.max(0,r/n));u.x=e.x+a*o,u.y=e.y+i*o}function se(u,t){return u?t?4:3:t?3:2}var G;(function(u){u[u.NONE=0]="NONE",u[u.EDGE=1]="EDGE",u[u.VERTEX=2]="VERTEX"})(G||(G={}));class ie{constructor(t,e){this.coords=t,this.coordsIndex=e}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}export{je as A,$e as a,Q as c,Oe as f,q as l,Pe as o,G as q};
