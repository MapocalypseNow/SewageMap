import{ag as q,a8 as v,a9 as V,gy as I,gz as D,gA as F,aa as j,aK as B,ax as N}from"./vendor-445d19db.js";const S=new q({classBreaksDef:"class-breaks-definition",uniqueValueDef:"unique-value-definition"});let x=class extends B{constructor(){super(...arguments),this.baseSymbol=null,this.colorRamp=null,this.type=null}};v([V({type:I,json:{write:!0}})],x.prototype,"baseSymbol",void 0),v([V({types:D,json:{read:{reader:F},write:!0}})],x.prototype,"colorRamp",void 0),v([V({json:{read:S.read,write:S.write}})],x.prototype,"type",void 0),x=v([j("esri.rest.support.ClassificationDefinition")],x);const T=x,$=new q({esriClassifyEqualInterval:"equal-interval",esriClassifyManual:"manual",esriClassifyNaturalBreaks:"natural-breaks",esriClassifyQuantile:"quantile",esriClassifyStandardDeviation:"standard-deviation",esriClassifyDefinedInterval:"defined-interval"}),z=new q({esriNormalizeByLog:"log",esriNormalizeByPercentOfTotal:"percent-of-total",esriNormalizeByField:"field"});let y=class extends T{constructor(){super(...arguments),this.breakCount=null,this.classificationField=null,this.classificationMethod=null,this.normalizationField=null,this.normalizationType=null,this.type="class-breaks-definition"}set standardDeviationInterval(t){this.classificationMethod==="standard-deviation"&&this._set("standardDeviationInterval",t)}set definedInterval(t){this.classificationMethod==="defined-interval"&&this._set("definedInterval",t)}};v([V({json:{write:!0}})],y.prototype,"breakCount",void 0),v([V({json:{write:!0}})],y.prototype,"classificationField",void 0),v([V({type:String,json:{read:$.read,write:$.write}})],y.prototype,"classificationMethod",void 0),v([V({json:{write:!0}})],y.prototype,"normalizationField",void 0),v([V({json:{read:z.read,write:z.write}})],y.prototype,"normalizationType",void 0),v([V({value:null,json:{write:!0}})],y.prototype,"standardDeviationInterval",null),v([V({value:null,json:{write:!0}})],y.prototype,"definedInterval",null),v([V()],y.prototype,"type",void 0),y=v([j("esri.rest.support.ClassBreaksDefinition")],y);const G=y,E=N.getLogger("esri.rest.support.generateRendererUtils");function M(t,r){return Number(t.toFixed(r))}function H(t){const{normalizationTotal:r}=t;return{classBreaks:L(t),normalizationTotal:r}}function L(t){const r=t.definition,{classificationMethod:n,breakCount:i,normalizationType:u,definedInterval:h}=r,c=[];let l=t.values;if(l.length===0)return[];l=l.sort((s,f)=>s-f);const d=l[0],p=l[l.length-1];if(n==="equal-interval")if(l.length>=i){const s=(p-d)/i;let f=d;for(let a=1;a<i;a++){const e=M(d+a*s,6);c.push({minValue:f,maxValue:e,label:b(f,e,u)}),f=e}c.push({minValue:f,maxValue:p,label:b(f,p,u)})}else l.forEach(s=>{c.push({minValue:s,maxValue:s,label:b(s,s,u)})});else if(n==="natural-breaks"){const s=R(l),f=t.valueFrequency||s.valueFrequency,a=_(s.uniqueValues,f,i);let e=d;for(let o=1;o<i;o++)if(s.uniqueValues.length>o){const m=M(s.uniqueValues[a[o]],6);c.push({minValue:e,maxValue:m,label:b(e,m,u)}),e=m}c.push({minValue:e,maxValue:p,label:b(e,p,u)})}else if(n==="quantile")if(l.length>=i&&d!==p){let s=d,f=Math.ceil(l.length/i),a=0;for(let e=1;e<i;e++){let o=f+a-1;o>l.length&&(o=l.length-1),o<0&&(o=0),c.push({minValue:s,maxValue:l[o],label:b(s,l[o],u)}),s=l[o],a+=f,f=Math.ceil((l.length-a)/(i-e))}c.push({minValue:s,maxValue:p,label:b(s,p,u)})}else{let s=-1;for(let f=0;f<l.length;f++){const a=l[f];a!==s&&(s=a,c.push({minValue:s,maxValue:a,label:b(s,a,u)}),s=a)}}else if(n==="standard-deviation"){const s=K(l),f=O(l,s);if(f===0)c.push({minValue:l[0],maxValue:l[0],label:b(l[0],l[0],u)});else{const a=U(d,p,i,s,f)*f;let e=0,o=d;for(let g=i;g>=1;g--){const k=M(s-(g-.5)*a,6);c.push({minValue:o,maxValue:k,label:b(o,k,u)}),o=k,e++}let m=M(s+.5*a,6);c.push({minValue:o,maxValue:m,label:b(o,m,u)}),o=m,e++;for(let g=1;g<=i;g++)m=e===2*i?p:M(s+(g+.5)*a,6),c.push({minValue:o,maxValue:m,label:b(o,m,u)}),o=m,e++}}else if(n==="defined-interval"){if(!h)return c;const s=l[0],f=l[l.length-1],a=Math.ceil((f-s)/h);let e=s;for(let o=1;o<a;o++){const m=M(s+o*h,6);c.push({minValue:e,maxValue:m,label:b(e,m,u)}),e=m}c.push({minValue:e,maxValue:f,label:b(e,f,u)})}return c}function b(t,r,n){let i=null;return i=t===r?n&&n==="percent-of-total"?t+"%":t.toString():n&&n==="percent-of-total"?t+"% - "+r+"%":t+" - "+r,i}function R(t){const r=[],n=[];let i=Number.MIN_VALUE,u=1,h=-1;for(let c=0;c<t.length;c++){const l=t[c];l===i?(u++,n[h]=u):l!==null&&(r.push(l),i=l,u=1,n.push(u),h++)}return{uniqueValues:r,valueFrequency:n}}function _(t,r,n){const i=t.length,u=[];n>i&&(n=i);for(let c=0;c<n;c++)u.push(Math.round(c*i/n-1));u.push(i-1);let h=C(u,t,r,n);return A(h.mean,h.sdcm,u,t,r,n)&&(h=C(u,t,r,n)),u}function C(t,r,n,i){let u=[],h=[],c=[],l=0;const d=[],p=[];for(let e=0;e<i;e++){const o=w(e,t,r,n);d.push(o.sbMean),p.push(o.sbSdcm),l+=p[e]}let s,f=l,a=!0;for(;a||l<f;){a=!1,u=[];for(let e=0;e<i;e++)u.push(t[e]);for(let e=0;e<i;e++)for(let o=t[e]+1;o<=t[e+1];o++)if(s=r[o],e>0&&o!==t[e+1]&&Math.abs(s-d[e])>Math.abs(s-d[e-1]))t[e]=o;else if(e<i-1&&t[e]!==o-1&&Math.abs(s-d[e])>Math.abs(s-d[e+1])){t[e+1]=o-1;break}f=l,l=0,h=[],c=[];for(let e=0;e<i;e++){h.push(d[e]),c.push(p[e]);const o=w(e,t,r,n);d[e]=o.sbMean,p[e]=o.sbSdcm,l+=p[e]}}if(l>f){for(let e=0;e<i;e++)t[e]=u[e],d[e]=h[e],p[e]=c[e];l=f}return{mean:d,sdcm:p}}function A(t,r,n,i,u,h){let c=0,l=0,d=0,p=0,s=!0;for(let f=0;f<2&&s;f++){f===0&&(s=!1);for(let a=0;a<h-1;a++)for(;n[a+1]+1!==n[a+2];){n[a+1]=n[a+1]+1;const e=w(a,n,i,u);d=e.sbMean,c=e.sbSdcm;const o=w(a+1,n,i,u);if(p=o.sbMean,l=o.sbSdcm,!(c+l<r[a]+r[a+1])){n[a+1]=n[a+1]-1;break}r[a]=c,r[a+1]=l,t[a]=d,t[a+1]=p,s=!0}for(let a=h-1;a>0;a--)for(;n[a]!==n[a-1]+1;){n[a]=n[a]-1;const e=w(a-1,n,i,u);d=e.sbMean,c=e.sbSdcm;const o=w(a,n,i,u);if(p=o.sbMean,l=o.sbSdcm,!(c+l<r[a-1]+r[a])){n[a]=n[a]+1;break}r[a-1]=c,r[a]=l,t[a-1]=d,t[a]=p,s=!0}}return s}function U(t,r,n,i,u){let h=Math.max(i-t,r-i)/u/n;return h=h>=1?1:h>=.5?.5:.25,h}function K(t){let r=0;for(let n=0;n<t.length;n++)r+=t[n];return r/=t.length,r}function O(t,r){let n=0;for(let i=0;i<t.length;i++){const u=t[i];n+=(u-r)*(u-r)}return n/=t.length,Math.sqrt(n)}function w(t,r,n,i){let u=0,h=0;for(let d=r[t]+1;d<=r[t+1];d++){const p=i[d];u+=n[d]*p,h+=p}h<=0&&E.warn("Exception in Natural Breaks calculation");const c=u/h;let l=0;for(let d=r[t]+1;d<=r[t+1];d++)l+=i[d]*(n[d]-c)**2;return{sbMean:c,sbSdcm:l}}export{H as a,G as l};
