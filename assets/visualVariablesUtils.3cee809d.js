import{l as h,dc as v,aJ as z}from"./vendor.f8a4aecc.js";import{L as r,g}from"./color.1638605e.js";import{A as S}from"./definitions.1d569ae6.js";import{l as $}from"./visualVariablesUtils.fe2e172f.js";const E=8388607,m=8388608,x=254,V=255,F=0,d=1,y=s=>(s&m)>>>23,L=s=>s&E,U=s=>y(s)===d?x:V;function R(s){return y(s)===d}function T(s,e){return((e?m:0)|s)>>>0}const Z=(s,e)=>s&&((...t)=>e.warn("DEBUG:",...t))||(()=>null),k=!1;function N(s,e){if(!s||!e)return s;switch(e){case"radius":case"distance":return 2*s;case"diameter":case"width":return s;case"area":return Math.sqrt(s)}return s}function _(s){return{value:s.value,size:v(s.size)}}function a(s){return(s!=null?s:[]).map(e=>_(e))}function c(s){if(typeof s=="string"||typeof s=="number")return v(s);const e=s;return{type:"size",expression:e.expression,stops:a(e.stops)}}const p=s=>{const e=[],t=[],n=a(s),o=n.length;for(let l=0;l<6;l++){const i=n[Math.min(l,o-1)];e.push(i.value),t.push(i.size==null?S:z(i.size))}return{values:new Float32Array(e),sizes:new Float32Array(t)}};function O(s){var n;const e=s&&s.length>0?{}:null,t=e?{}:null;if(!e||!t)return{vvFields:e,vvRanges:t};for(const o of s)if(o.field&&(e[o.type]=o.field),o.type==="size"){t.size||(t.size={});const l=o;switch($(l)){case r.SIZE_MINMAX_VALUE:t.size.minMaxValue={minDataValue:l.minDataValue,maxDataValue:l.maxDataValue,minSize:c(l.minSize),maxSize:c(l.maxSize)};break;case r.SIZE_SCALE_STOPS:t.size.scaleStops={stops:a(l.stops)};break;case r.SIZE_FIELD_STOPS:if(l.levels){const i={};for(const u in l.levels)i[u]=p(l.levels[u]);t.size.fieldStops={type:"level-dependent",levels:i}}else t.size.fieldStops={type:"static",...p(l.stops)};break;case r.SIZE_UNIT_VALUE:t.size.unitValue={unit:l.valueUnit,valueRepresentation:(n=l.valueRepresentation)!=null?n:void 0}}}else if(o.type==="color")t.color=I(o);else if(o.type==="opacity")t.opacity=A(o);else if(o.type==="rotation"){const l=o;t.rotation={type:l.rotationType}}return{vvFields:e,vvRanges:t}}function A(s){const e={values:[0,0,0,0,0,0,0,0],opacities:[0,0,0,0,0,0,0,0]};if(typeof s.field=="string"){if(!s.stops)return null;{if(s.stops.length>8)return null;const t=s.stops;for(let n=0;n<8;++n){const o=t[Math.min(n,t.length-1)];e.values[n]=o.value,e.opacities[n]=o.opacity}}}else{if(!(s.stops&&s.stops.length>=0))return null;{const t=s.stops&&s.stops.length>=0?s.stops[0].opacity:0;for(let n=0;n<8;n++)e.values[n]=1/0,e.opacities[n]=t}}return e}function f(s,e,t){s[4*e+0]=t.r/255,s[4*e+1]=t.g/255,s[4*e+2]=t.b/255,s[4*e+3]=t.a}function I(s){if(h(s)||s.normalizationField)return null;const e={field:null,values:[0,0,0,0,0,0,0,0],colors:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]};if(typeof s.field=="string"){if(!s.stops)return null;{if(s.stops.length>8)return null;e.field=s.field;const t=s.stops;for(let n=0;n<8;++n){const o=t[Math.min(n,t.length-1)];e.values[n]=o.value,f(e.colors,n,o.color)}}}else{if(!(s.stops&&s.stops.length>=0))return null;{const t=s.stops&&s.stops.length>=0&&s.stops[0].color;for(let n=0;n<8;n++)e.values[n]=1/0,f(e.colors,n,t)}}for(let t=0;t<32;t+=4)g(e.colors,t,!0);return e}export{E as a,O as b,d as c,y as e,L as f,U as i,k as l,Z as n,R as p,N as r,T as s,F as u};
