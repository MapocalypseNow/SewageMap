import"./geometry-da69b92c.js";import{u as h}from"./workers-a88acec1.js";import{w as l}from"./Extent-d21a2637.js";import{v as y}from"./jsonUtils-7333a4d1.js";import"./ensureType-9613b5f0.js";import"./string-cc430a78.js";import"./typedArrayUtil-bd69bba0.js";import"./Error-8814705f.js";import"./Polyline-98ddf509.js";import"./cast-4943406f.js";import"./nextTick-3ee5a785.js";import"./promiseUtils-ec14a623.js";import"./typeUtils-98cd71e2.js";import"./jsonMap-9318d50f.js";import"./preload-helper-6c8d3039.js";import"./Connection-2ff63c33.js";import"./Queue-f6edac75.js";import"./request-9ab300ca.js";import"./assets-2905a8db.js";import"./intl-e6f005e0.js";import"./number-d7fe9942.js";import"./locale-30120714.js";import"./messages-d8933302.js";function n(e){var t;return Array.isArray(e)?(t=e[0])==null?void 0:t.spatialReference:e==null?void 0:e.spatialReference}function p(e){return e&&(Array.isArray(e)?e.map(p):e.toJSON?e.toJSON():e)}function o(e){return Array.isArray(e)?e.map(t=>y(t)):y(e)}function S(e,t){let r;return Array.isArray(e)?r=e:(r=[],r.push(e),t!=null&&r.push(t)),r}let f;async function w(){return f||(f=h("geometryEngineWorker",{strategy:"distributed"})),f}async function a(e,t){return(await w()).invoke("executeGEOperation",{operation:e,parameters:p(t)})}async function d(e,t){const r=await w();return Promise.all(r.broadcast("executeGEOperation",{operation:e,parameters:p(t)}))}function $(e){return a("extendedSpatialReferenceInfo",[e])}async function W(e,t){return o(await a("clip",[n(e),e,t]))}async function F(e,t){return o(await a("cut",[n(e),e,t]))}function K(e,t){return a("contains",[n(e),e,t])}function M(e,t){return a("crosses",[n(e),e,t])}function Q(e,t,r){return a("distance",[n(e),e,t,r])}function U(e,t){return a("equals",[n(e),e,t])}function X(e,t){return a("intersects",[n(e),e,t])}function Y(e,t){return a("touches",[n(e),e,t])}function Z(e,t){return a("within",[n(e),e,t])}function _(e,t){return a("disjoint",[n(e),e,t])}function ee(e,t){return a("overlaps",[n(e),e,t])}function te(e,t,r){return a("relate",[n(e),e,t,r])}function re(e){return a("isSimple",[n(e),e])}async function ae(e){return o(await a("simplify",[n(e),e]))}async function ne(e,t=!1){return o(await a("convexHull",[n(e),e,t]))}async function ie(e,t){return o(await a("difference",[n(e),e,t]))}async function oe(e,t){return o(await a("symmetricDifference",[n(e),e,t]))}async function ce(e,t){return o(await a("intersect",[n(e),e,t]))}async function se(e,t=null){const r=S(e,t);return o(await a("union",[n(r),r]))}async function ue(e,t,r,i,c,u){return o(await a("offset",[n(e),e,t,r,i,c,u]))}async function fe(e,t,r,i=!1){const c=[n(e),e,t,r,i];return o(await a("buffer",c))}async function le(e,t,r,i,c,u){const g=[n(e),e,t,r,i,c,u];return o(await a("geodesicBuffer",g))}async function pe(e,t,r=!0){const i=await a("nearestCoordinate",[n(e),e,t,r]);return{...i,coordinate:l.fromJSON(i.coordinate)}}async function me(e,t){const r=await a("nearestVertex",[n(e),e,t]);return{...r,coordinate:l.fromJSON(r.coordinate)}}async function ye(e,t,r,i){return(await a("nearestVertices",[n(e),e,t,r,i])).map(c=>({...c,coordinate:l.fromJSON(c.coordinate)}))}function m(e){var t;return"xmin"in e?e.center:"x"in e?e:(t=e.extent)==null?void 0:t.center}async function we(e,t,r){if(e==null)throw new s;const i=e.spatialReference;if((r=r??m(e))==null)throw new s;const c=e.constructor.fromJSON(await a("rotate",[i,e,t,r]));return c.spatialReference=i,c}async function de(e,t){if(e==null)throw new s;const r=e.spatialReference;if((t=t??m(e))==null)throw new s;const i=e.constructor.fromJSON(await a("flipHorizontal",[r,e,t]));return i.spatialReference=r,i}async function ge(e,t){if(e==null)throw new s;const r=e.spatialReference;if((t=t??m(e))==null)throw new s;const i=e.constructor.fromJSON(await a("flipVertical",[r,e,t]));return i.spatialReference=r,i}async function he(e,t,r,i){return o(await a("generalize",[n(e),e,t,r,i]))}async function Se(e,t,r){return o(await a("densify",[n(e),e,t,r]))}async function xe(e,t,r,i=0){return o(await a("geodesicDensify",[n(e),e,t,r,i]))}function Re(e,t){return a("planarArea",[n(e),e,t])}function Ae(e,t){return a("planarLength",[n(e),e,t])}function Oe(e,t,r){return a("geodesicArea",[n(e),e,t,r])}function De(e,t,r){return a("geodesicLength",[n(e),e,t,r])}async function Je(e,t){return o(await a("intersectLinesToPoints",[n(e),e,t]))}async function Ne(e,t){await d("changeDefaultSpatialReferenceTolerance",[e,t])}async function ve(e){await d("clearDefaultSpatialReferenceTolerance",[e])}class s extends Error{constructor(){super("Illegal Argument Exception")}}export{fe as buffer,Ne as changeDefaultSpatialReferenceTolerance,ve as clearDefaultSpatialReferenceTolerance,W as clip,K as contains,ne as convexHull,M as crosses,F as cut,Se as densify,ie as difference,_ as disjoint,Q as distance,U as equals,$ as extendedSpatialReferenceInfo,de as flipHorizontal,ge as flipVertical,he as generalize,Oe as geodesicArea,le as geodesicBuffer,xe as geodesicDensify,De as geodesicLength,ce as intersect,Je as intersectLinesToPoints,X as intersects,re as isSimple,pe as nearestCoordinate,me as nearestVertex,ye as nearestVertices,ue as offset,ee as overlaps,Re as planarArea,Ae as planarLength,te as relate,we as rotate,ae as simplify,oe as symmetricDifference,Y as touches,se as union,Z as within};
