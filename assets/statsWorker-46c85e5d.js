import"./geometry-da69b92c.js";import{a as C}from"./Error-8814705f.js";import{e as O,r as E}from"./typedArrayUtil-bd69bba0.js";import{u as R}from"./screenUtils-7afeb41c.js";import{k as U,m as _,b as k,w as A}from"./Extent-d21a2637.js";import{c as V,x as Y,O as q,m as B,f as G,d as W,V as Z,T as H,F as J,D as K,N as L,S as Q}from"./utils-179e89a7.js";import{i as X,e as ee}from"./fieldUtils-605e1353.js";import{y as ie,m as ne}from"./heatmapUtils-90a13d85.js";import{i as ae}from"./arcadeOnDemand-5200ab6b.js";let z=null;function te(i,e,n){return i.x<0?i.x+=e:i.x>n&&(i.x-=e),i}function oe(i,e,n,a){const t=_(n)?k(n):null,l=t?Math.round((t.valid[1]-t.valid[0])/e.scale[0]):null;return i.map(r=>{const o=new A(O(r.geometry));return q(e,o,o,o.hasZ,o.hasM),r.geometry=t?te(o,l,a[0]):o,r})}function le(i,e=18,n,a,t,l){const r=new Float64Array(t*l);e=Math.round(R(e));let o=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,u=0,d=0,m=0,c=0;const I=ie(a,n);for(const{geometry:T,attributes:y}of i){const{x:p,y:f}=T,x=Math.max(0,p-e),g=Math.max(0,f-e),D=Math.min(l,f+e),N=Math.min(t,p+e),P=+I(y);for(let F=g;F<D;F++)for(let $=x;$<N;$++){const M=F*t+$,j=ne($-p,F-f,e),S=r[M];u=r[M]+=j*P;const b=u-S;d+=b,m+=b*b,u<o&&(o=u),u>s&&(s=u),c++}}if(!c)return{mean:0,stddev:0,min:0,max:0,mid:0,count:0};const h=(s-o)/2;return{mean:d/c,stdDev:Math.sqrt((m-d*d/c)/c),min:o,max:s,mid:h,count:c}}async function w(i,e){if(!e)return[];const{field:n,field2:a,field3:t,fieldDelimiter:l}=i,r=i.valueExpression,o=i.normalizationType,s=i.normalizationField,u=i.normalizationTotal,d=[],m=i.viewInfoParams;let c=null,I=null;if(r){if(!z){const{arcadeUtils:y}=await ae();z=y}c=z.createFunction(r),I=m&&z.getViewInfo({viewingMode:m.viewingMode,scale:m.scale,spatialReference:new U(m.spatialReference)})}const h=i.fieldInfos,T=!(e[0]&&"declaredClass"in e[0]&&e[0].declaredClass==="esri.Graphic")&&h?{fields:h}:null;return e.forEach(y=>{const p=y.attributes;let f;if(r){const x=T?{...y,layer:T}:y,g=z.createExecContext(x,I);f=z.executeFunction(c,g)}else p&&(f=p[n],a&&(f=`${V(f)}${l}${V(p[a])}`,t&&(f=`${f}${l}${V(p[t])}`)));if(o&&typeof f=="number"&&isFinite(f)){const x=p&&parseFloat(p[s]);f=Y(f,o,x,u)}d.push(f)}),d}function we(i){const e=i.field,n=i.normalizationType,a=i.normalizationField;let t;return n==="field"?t="(NOT "+a+" = 0)":n!=="log"&&n!=="natural-log"&&n!=="square-root"||(t=`(${e} > 0)`),t}function v(i,e){return new C(i,e)}function ge(i,e,n){const a=e!=null?i+" >= "+e:"",t=n!=null?i+" <= "+n:"";let l="";return l=a&&t?re(a,t):a||t,l?"("+l+")":""}function be(i,e,n,a){let t=null;return e?e.name!==i.objectIdField&&a.includes(e.type)||(t=v(n,"'field' should be one of these types: "+a.join(","))):t=v(n,"'field' is not defined in the layer schema"),t}function Ve(i,e,n){let a;return e?e.name!==i.objectIdField&&X(e)||(a=v(n,"'field' should be one of these numeric types: "+ee.join(","))):a=v(n,"'field' is not defined in the layer schema"),a}function re(i,e){let n=E(i)?i:"";return E(e)&&e&&(n=n?"("+n+") AND ("+e+")":e),n}function Me(i,e){if(i&&i.spatialRelationship!=="intersects")return v(e,"Only 'intersects' spatialRelationship is supported for featureFilter")}function Ee(i,e,n){const a=se({layer:i,fields:e});if(a.length)return v(n,"Unknown fields: "+a.join(", ")+". You can only use fields defined in the layer schema");const t=ue({layer:i,fields:e});return t.length?v(n,"Unsupported fields: "+t.join(", ")+". You can only use fields that can be fetched i.e. AdapterFieldUsageInfo.supportsStatistics must be true"):void 0}function se(i){const e=i.layer;return i.fields.filter(n=>!e.getField(n))}function ue(i){const e=i.layer;return i.fields.filter(n=>{const a=e.getFieldUsageInfo(n);return!a||!a.supportsStatistics})}async function fe(i){const{attribute:e,features:n}=i,{normalizationType:a,normalizationField:t,minValue:l,maxValue:r,fieldType:o}=e,s=await w({field:e.field,valueExpression:e.valueExpression,normalizationType:a,normalizationField:t,normalizationTotal:e.normalizationTotal,viewInfoParams:e.viewInfoParams,fieldInfos:e.fieldInfos},n),u=B({normalizationType:a,normalizationField:t,minValue:l,maxValue:r}),d={value:.5,fieldType:o},m=o==="esriFieldTypeString"?G({values:s,supportsNullCount:u,percentileParams:d}):W({values:s,minValue:l,maxValue:r,useSampleStdDev:!a,supportsNullCount:u,percentileParams:d});return Z(m,o==="esriFieldTypeDate")}async function de(i){const{attribute:e,features:n}=i,a=await w({field:e.field,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:e.valueExpression,viewInfoParams:e.viewInfoParams,fieldInfos:e.fieldInfos},n),t=H(a);return J(t,e.domains,e.returnAllCodedValues,e.fieldDelimiter)}async function me(i){const{attribute:e,features:n}=i,{field:a,normalizationType:t,normalizationField:l,normalizationTotal:r,classificationMethod:o}=e,s=await w({field:a,valueExpression:e.valueExpression,normalizationType:t,normalizationField:l,normalizationTotal:r,viewInfoParams:e.viewInfoParams,fieldInfos:e.fieldInfos},n),u=K(s,{field:a,normalizationType:t,normalizationField:l,normalizationTotal:r,classificationMethod:o,standardDeviationInterval:e.standardDeviationInterval,numClasses:e.numClasses,minValue:e.minValue,maxValue:e.maxValue});return L(u,o)}async function ce(i){const{attribute:e,features:n}=i,{field:a,normalizationType:t,normalizationField:l,normalizationTotal:r,classificationMethod:o}=e,s=await w({field:a,valueExpression:e.valueExpression,normalizationType:t,normalizationField:l,normalizationTotal:r,viewInfoParams:e.viewInfoParams,fieldInfos:e.fieldInfos},n);return Q(s,{field:a,normalizationType:t,normalizationField:l,normalizationTotal:r,classificationMethod:o,standardDeviationInterval:e.standardDeviationInterval,numBins:e.numBins,minValue:e.minValue,maxValue:e.maxValue})}async function pe(i){const{attribute:e,features:n}=i,{field:a,radius:t,fieldOffset:l,transform:r,spatialReference:o,size:s}=e,u=oe(n,r,o,s),{count:d,min:m,max:c,mean:I,stdDev:h}=le(u,t,l,a,s[0],s[1]);return{count:d,min:m,max:c,avg:I,stddev:h}}const De=Object.freeze(Object.defineProperty({__proto__:null,classBreaks:me,heatmapStatistics:pe,histogram:ce,summaryStatistics:fe,uniqueValues:de},Symbol.toStringTag,{value:"Module"}));export{Ve as E,Ee as M,re as N,be as a,ge as b,ce as c,fe as d,w as j,de as p,De as s,me as v,Me as w,we as x,pe as z};
